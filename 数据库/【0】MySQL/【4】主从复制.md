[TOC]

# 相关面试题

1. [mysql怎么实现主从复制？](#t2) 【3】

2. [mysql双主架构在不分表的情况下保证数据一致性](https://blog.csdn.net/weixin_30444111/article/details/113605314)【2】

# 主从复制

## 为什么需要主从复制

- 在业务复杂的系统中，有这么一个情景，有一句sq语句需要锁表，导致暂时不能使用读的服务，那么就很影响运行中的业务，使用主从复制，让主库负责写，从库负责读，这样，即使主库出现了锁表的情景，通过读从库也可以保证业务的正常运作。
- 做数据的热备
- 架构的扩展。业务量越来越大，I/Q访问频率过高，单机无法满足，此时做多库的存储，降低磁盘I/O访问的频率，提高单个机器的I/O性能。

## 什么是主从复制

MySQL主从复制是指数据可以从一个MySQL数据库服务器主节点复制到一个或多个从节点。MySQL 默认采用**异步复制方式**，这样从节点不用一直访问主服务器来更新自己的数据，数据的更新可以在远程连接上进行，从节点可以复制主数据库中的所有数据库或者特定的数据库，或者特定的表。

## mysql复制原理

**原理**：<a name="t1"></a>

- master服务器将数据的改变记录二进制**bin log**日志，当master上的数据发生改变时，则将其改变写入二进制日志中；		

- slave服务器会在一定时间间隔内对master二进制日志进行探测其是否发生改变，如果发生改变，则开始一个I/OThread请求master二进制事件

- 同时主节点为每个I/O线程启动一个dump线程，用于向其发送二进制事件，并保存至从节点本地的中继日志中，从节点将启动SQL线程从中继日志中读取二进制日志，在本地重放，使得其数据和主节点的保持一致，最后I/OThread和SQLThread将进入睡眠状态，等待下一次被唤醒。

**也就是说**：

- 从库会生成两个线程，一个I/O线程，一个SQL线程;
- I/O线程会去请求主库的binlog，并将得到的binlog写到本地的relay一log（中继日志）文件中;
- 主库会生成一个log dump线程，用来给从库I/O线程传binlog;
- SQL线程，会读取relay log文件中的日志，并解析成sql语句逐一执行;

**注意**：

- master将操作语句记录到binlog日志中，然后授予slave远程连接的权限（master一定要开启binlog二进制日志功能；通常为了数据安全考虑，slave也开启binlog功能）。
- slave开启两个线程：IO线程和SQL线程。其中：IO线程负责读取master的binlog内容到中继日志relay log里；SQL线程负责从relay log日志里读出binlog内容，并更新到slave的数据库里，这样就能保证slave数据和master数据保持一致了。
- Mysql复制至少需要两个Mysql的服务，当然Mysql服务可以分布在不同的服务器上，也可以在一台服务器上启动多个服务。
- Mysql复制最好确保master和slave服务器上的Mysql版本相同（如果不能满足版本一致，那么要保证master主节点的版本低于slave从节点的版本）
- master和slave两节点间时间需同步

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220129132431074.png" alt="image一20220129132431074" style="zoom:67%;" />

**具体步骤**：

1、从库通过手工执行change  master to 语句连接主库，提供了连接的用户一切条件（user 、password、port、ip），并且让从库知道，二进制日志的起点位置（file名 position 号）；  start  slave

2、从库的IO线程和主库的dump线程建立连接。

3、从库根据change  master  to 语句提供的file名和position号，IO线程向主库发起binlog的请求。

4、主库dump线程根据从库的请求，将本地binlog以events的方式发给从库IO线程。

5、从库IO线程接收binlog  events，并存放到本地relay一log中，传送过来的信息，会记录到master.info中

6、从库SQL线程应用relay一log，并且把应用过的记录到relay一log.info中，默认情况下，已经应用过的relay 会自动被清理purge

## mysql主从形式

## 一主一从

![1570714549624](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/1570714549624.png)

## 主主复制（双主结构）

![1570714565647](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/1570714565647.png)

**MySQL双主（主主）架构方案思路是:**

**1.两台mysql都可读写，互为主备，默认只使用一台（masterA）负责数据的写入，另一台（masterB）备用；**

**2.masterA是masterB的主库，masterB又是masterA的主库，它们互为主从；**

**3.两台主库之间做高可用,可以采用keepalived等方案（使用VIP对外提供服务）；**

**4.所有提供服务的从服务器与masterB进行主从同步（双主多从）;**

**5.建议采用高可用策略的时候，masterA或masterB均不因宕机恢复后而抢占VIP（非抢占模式）；**

这样做可以在一定程度上保证主库的高可用,在一台主库down掉之后,可以在极短的时间内切换到另一台主库上（尽可能减少主库宕机对业务造成的影响），减少了主从同步给线上主库带来的压力；

但是也有几个不足的地方:

**1.masterB可能会一直处于空闲状态（可以用它当从库，负责部分查询）；**

**2.主库后面提供服务的从库要等masterB先同步完了数据后才能去masterB上去同步数据，这样可能会造成一定程度的同步延时；**

架构的简易图如下:

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220129191222763.png" alt="image-20220129191222763" style="zoom:67%;" />



## 一主多从

![1570714576819](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/1570714576819.png)

## 多主一从

![image一20220129161212543](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220129161212543.png)

## 联级复制

![1570714660961](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/1570714660961.png)

# 主从复制延迟问题

## 产生延时的原因

- 在某些部署环境中，备库所在的机器性能要比主库所在的机器性能差。此时如果机器的资源不足的话就会影响备库同步的效率;
- 备库充当了读库， 一般情况下主要写的压力在于主库，那么备库会提供一部分读的压力，而如果备库的查询压力过大的话，备库的查询消耗了大量的CPU资源，那么必不可少的就会影响同步的速度；
- 大事务执行，如果主库的一个事务执行了10分钟，而binlog的写入必须要等待事务完成之后，才会传入备库，那么此时在开始执行的时候就已经延迟了10分钟了；
- **主库的写操作是顺序写binlog，从库单线程去主库顺序读binlog，从库取到binlog之 后在本地执行；mysq|的主从复制都是单线程的操作，但是由于主库是顺序写，所以效率很高，而从库也是顺序读取主库的日志，此时的效率也是比较高的，但是当数据拉取回来之后变成了随机的操作，而不是顺序的，所以此时成本会提高。**
- 从库在同步数据的同时，可能跟其他查询的线程发生锁抢占的情况，此时也会发生延时；
- 当主库的TPS并发非常高的时候， 产生的DDL数量超过了一一个线程所能承受的范围的时候，那么也可能带来延迟；
- 在进行binlog日志传输的时候， 如果网络带宽也不是很好，那么网络延迟也可能造成数据同步延迟这些就是可能会造成备库延迟的原因

## mysql主从同步延时分析

mysql的主从复制都是单线程的操作，主库对所有DDL和DML产生的日志写进binlog，由于binlog是顺序写，所以效率很高，slave的sql thread线程将主库的DDL和DML操作事件在slave中重放。DML和DDL的IO操作是随机的，不是顺序，所以成本要高很多，另一方面，由于sql thread也是单线程的，当主库的并发较高时，产生的DML数量超过slave的SQL thread所能处理的速度，或者当slave中有大型query语句产生了锁等待，那么延时就产生了。

**解决方案**：

​		1.业务的持久化层的实现采用分库架构，mysql服务可平行扩展，分散压力。

​		2.单个库读写分离，一主多从，主写从读，分散压力。这样从库压力比主库高，保护主库。

​		3.服务的基础架构在业务和mysql之间加入memcache或者redis的cache层。降低mysql的读压力。

​		4.不同业务的mysql物理上放在不同机器，分散压力。

​		5.使用比主库更好的硬件设备作为slave，mysql压力小，延迟自然会变小。

​		6.使用更加强劲的硬件设备

**mysql5.7之后使用MTS并行复制技术，永久解决复制延时问题一一一一一一自学**

## 根本上解决主从复制的延迟问题

很多同学在自己线上的业务系统中都使用了mysq的主从复制，但是大家需要注意的是.并不是所有的场景都适合主从复制，一般情况下是读要远远多于写的应用，同时读的时效性要求不那么高的场景。如果真实场景中真的要求立马读取到更新之后的数据，那么就只能强制读取主库的数据，所以在进行实现的时候要考虑实际的应用场景，不要为了技术而技术，这是很严重的事情。
在mysql5.6版本之后引入了一个概念，就是我们通常说的并行复制，如下图：

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220129172118954.png" alt="image-20220129172118954" style="zoom: 50%;" />

通过上图我们可以发现其实所谓的并行复制，就是在中间添加了一个分发的环节，也就是说原来的sql _thread变成了现在的coordinator组件，当日志来了之后，coordinator负责读取日志信息以及分发事务，真正的日志执行的过程是放在了worker线程上，由多个线程并行的去执行。

通过上述的配置可以完成我们说的并行复制，但是此时你需要思考几个问题

1. 在并行操作的时候，可能会有并发的事务问题，我们的备库在执行的时候可以按照轮训的方式发送给各个worker吗?

   **答案**是不行的，因为事务被分发给worker以后，不同的worker就开始独立执行了。但是，由于CPU的不同调度策略，很可能第二个事务最终比第一个事务先执行，而如果刚刚好他们修改的是同一行数据，那么因为执行顺序的问题，可能导致主备的数据不一致。

2. 同一个事务的多个更新语句，能不能分给不同的worker来执行呢?

   **答案**是也不行，举个例子， 一个事务更新了表t1和表t2中的各一行, 如果这两条更新语句被分到不同worker的话，虽然最终的结果是主备一致的，但如果表t1执行完成的瞬间，备库上有一个查询，就会看到这个事务更新了一半的结果，破坏了事务逻辑的隔离性。

我们通过讲解上述两个问题的最主要目的是为了说明一件事，就是coordinator在进行分发的时候，需要遵循的策略是什么?

1. 不能造成更新覆盖。这就要求更新同一行的两个事务，必须被分发到同一个worker中；
2. 同一个事务不能被拆开，必须放到同一个worker中；

听完上面的描述，我们来说一下具体实现的原理和过程。
如果让我们自己来设计的话，我们应该如何操作呢?这是一个值得思考的问题。其实如果按照实际的操作的话，我们可以按照粒度进行分类，分为**按库分发**，**按表分发**，**按行分发**。
其实不管按照什么方式进行分发，大家需要注意的就是在分发的时候必须要满足我们上面说的两条规则，所以当我们进行分发的时候要在每一个worker上定义一 个hash表，用来保存当前这个work正在执行的事务所涉及到的表，hash表的key值按照不同的粒度需要存储不同的值：

- 按库分发: key值是**数据库的名字**
- 按表分发: key值是**库名+表名**
- 按行分发: key值是**库名+表名+唯一键（主键/唯一键）**

**补充**：如果涉及**表关联操作**，就必须将其交给同一个worker处理。

### MySQL5.6版本的并行复制策略

MySQL5.6版本支持了并行复制，只是支持的粒度是按库并行。用于决定分发策略的hash表里，key是数据库名这个策略的并行效果取决于压力模型。如果在主库上有多个DB，并且各个DB的压力均衡，使用这个策略的效果会很好这个策略的两个优势：

- 构造hash值的时候很快，只需要库名
- 不要求binlog的格式，因为statement格式的binlog也可以很容易拿到库名

可以创建不同的DB，把相同热度的表均匀分到这些不同的DB中，强行使用这个策略

### MariaDB的并行复制策略

redo log组提交优化，而MariaDB的并行复制策略利用的就是这个特性：

- 能够在同一个组里提交的事务，一定不会修改同一行
- 主库上可以并行执行的事务，备库上也一定是可以并行执行的

在实现上，MariaDB是这么做的：

1. 在一组里面一起提交的事务，有一个相同的commit_id，下一组就是commit_id+1
2. commit_id直接写到binlog里面
3. 传到备库应用的时候，相同commit_id的事务分发到多个worker执行
4. 这一组全部执行完成后，coordinator再去取下一批

下图中假设三组事务在主库的执行情况，trx1、trx2和trx3提交的时候，trx4、trx5和trx6是在执行的。这样，在第一组事务提交完成的时候，下一组事务很快就会进入commit状态

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220129184501367.png" alt="image-20220129184501367" style="zoom: 67%;" />

按照MariaDB的并行复制策略，备库上的执行效果如下图：

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220129184524476.png" alt="image-20220129184524476" style="zoom:67%;" />

在备库上执行的时候，要等第一组事务完全执行完成后，第二组事务才能开始执行，这样系统的吞吐量就不够

另外，这个方案容易被大事务拖后腿。假设trx2是一个超大事务，那么在备库应用的时候，trx1和trx3执行完成后，下一组才能开始执行。只有一个worker线程在工作，是对资源的浪费

### MySQL5.7版本的并行复制策略

MySQL5.7版本由参数`slave-parallel-type`来控制并行复制策略：

- 配置为DATABASE，表示使用MySQL5.6版本的按库并行策略
- 配置为LOGICAL_CLOCK，表示的就是类似MariaDB的策略。[MySQL](https://cloud.tencent.com/product/cdb?from=10680)在此基础上做了优化

同时处于执行状态的所有事务，是不是可以并行？

不可以，因为这里面可能有由于锁冲突而处于锁等待状态的事务。如果这些事务在备库上被分配到不同的worker，就会出现备库跟主库不一致的情况

而MariaDB这个策略的核心是所有处于commit状态的事务可以并行。事务处于commit状态表示已经通过了锁冲突的检验了

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220129184610935.png" alt="image-20220129184610935" style="zoom: 67%;" />

其实只要能够达到redo log prepare阶段就表示事务已经通过锁冲突的检验了

因此，mysql5.7的并行复制策略的思想是：

- **同时处于prepare状态的事务，在备库执行是可以并行的**；
- **处于prepare状态的事务，与处于commit状态的事务之间，在备库上执行也是可以并行的**。

基于这样的处理机制，我们可以将大部分的日志处于prepare状态，因此可以设置：

- binlog_group_commit_sync_delay参数，表示延迟多少微秒后才调用fsync；

- binlog_group_commit_sync_no_delay_count参数，表示累积多少次以后才调用fsync；

这两个参数是用于故意拉长binlog从write到fsync的时间，以此减少binlog的写盘次数。在MySQL5.7的并行复制策略里，它们可以用来制造更多的同时处于prepare阶段的事务。这样就**增加了备库复制的并行度**。也就是说，这**两个参数既可以故意让主库提交得慢些，又可以让备库执行得快些**。

