[TOC]

# 相关面试题

1. 关系型数据库和非关系型数据库
2. 数据库的范式？
3. 外键的约束的作用
4. 用户id怎么生成？（DB自增不可靠，因为可能有多个机器共用一个DB，自增会溢出。从代码层面解释如何生成）?
5. 慢SQL优化；
6. 怎么保证DB里面的数据不会被修改（权限问题不考虑，假设用户有权限）？
6. 为什么需要序列化？有什么序列化的方式？



# 概述

数据库知识基础，这部分内容一定要理解记忆。虽然这部分内容只是理论知识，但是非常重要，这是后面学习 MySQL 数据库的基础。PS: 这部分内容由于涉及太多概念性内容，所以参考了维基百科和百度百科相应的介绍。

什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?

- **数据库** : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。
- **数据库管理系统** : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。
- **数据库系统** : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。
- **数据库管理员** : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。

数据库系统基本构成如下图所示：

![数据库系统基本构成](https://img-blog.csdnimg.cn/img_convert/e21120184e63406526a4e873cacd23f2.png)

# 关系型数据库&非关系型数据库

当前主流的关系型数据库：有Oracle、DB2、Microsoft SQL Server、Microsoft Access、MySQL等。

非关系型数据库：NoSql、Cloudant。

## 非关系型数据库的

### 优点

1. 性能NoSQL是基于键值对的，可以想象成表中的主键和值的对应关系，而且不需要经过SQL层的解析，所以**性能非常高**。

2. **可扩展性**同样也是因为基于键值对，数据之间没有耦合性，所以非常容易水平扩展。

3. 成本：NoSQL数据库简单易部署，基本都是开源软件，不需要像使用oracle那样花费大量成本购买使用，相比关系型数据库**价格便宜**。

4. **查询速度**：NoSQL数据库将数据存储于缓存之中，关系型数据库将数据存储在硬盘中，自然查询速度远不及nosql数据库。

5. **存储数据的格式**：NoSQL的存储格式是key,value形式、文档形式、图片形式等等，所以可以存储基础类型以及对象或者是集合等各种格式，而数据库则只支持基础类型。

### 缺点

1. 维护的工具和资料有限，因为nosql是属于新的技术，不能和关系型数据库10几年的技术同日而语。
2. 不提供对sql的支持，如果不支持sql这样的工业标准，将产生一定用户的学习和使用成本。
3. 不提供关系型数据库对事物的处理。

## 关系型数据库

### 优势

1. **复杂查询**可以用SQL语句方便的在一个表以及多个表之间做非常复杂的数据查询，如join。

2. **最大优势：**保持数据的一致性（事务处理） 事务支持使得对于安全性能很高的数据访问要求得以实现。关系型数据库把所有的数据都通过行和列的二元表现形式表示出来。

3. 由于以标准化为前提，数据更新的开销很小（相同的字段基本上都只有一处）

### 缺点

1. 扩展性：关系型数据库有类似join这样的多表查询机制的限制导致扩展很艰难。
2. 不擅长如下处理
3. 大量数据的写入处理
4. 为有数据更新的表做索引或表结构（schema）变更
5. 字段不固定时应用
6. 对简单查询需要快速返回结果的处理



# 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？

- **元组** ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。
- **码** ：码就是能唯一标识实体的属性，对应表中的列。
- **候选码** ： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。
- **主码** : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。
- **外码** : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。
- **主属性** ： 候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。
- **非主属性：** 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。

# 主键和外键有什么区别?

- **主键(主码)** ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。
- **外键(外码)** ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。

# 为什么不推荐使用外键与级联？

对于外键和级联，阿里巴巴开发手册这样说到：

> 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。
>
> 说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群; 级联更新是强阻塞，存在数据库更新风暴的风 险; 外键影响数据库的插入速度

首先我们明确一点，外键约束是一种约束，这个约束的存在，会保证表间数据的关系“始终完整”。因此，外键约束的存在，并非全然没有优点。
比如使用外键，可以

- 保证数据的完整性和一致性 
- 级联操作方便
- 将数据完整性判断托付给了数据库完成，减少了程序的代码量

**FOREIGN KEY 约束的主要目的是控制存储在外键表中的数据，但它还可以控制对主键表中数据的修改。**

然而，鱼和熊掌不可兼得。外键是能够保证数据的完整性，但是会给系统带来很多缺陷。正是因为这些缺陷，才导致我们不推荐使用外键，具体如下

**性能问题**

假设一张表名为user_tb。那么这张表里有两个外键字段，指向两张表。那么，每次往user_tb表里插入数据，就必须往两个外键对应的表里查询是否有对应数据。如果交由程序控制，这种查询过程就可以控制在我们手里，可以省略一些不必要的查询过程。但是如果由数据库控制，则是必须要去这两张表里判断。

**并发问题**

在使用外键的情况下，每次修改数据都需要去另外一个表检查数据,需要获取额外的锁。若是在高并发大流量事务场景，使用外键更容易造成死锁。

**扩展性问题**

这里主要是分为两点

- 做平台迁移方便，比如你从`Mysql`迁移到`Oracle`，像触发器、外键这种东西，都可以利用框架本身的特性来实现，而不用依赖于数据库本身的特性，做迁移更加方便。
- 分库分表方便，在水平拆分和分库的情况下，外键是无法生效的。将数据间关系的维护，放入应用程序中，为将来的分库分表省去很多的麻烦。

**技术问题**

使用外键，其实将应用程序应该执行的判断逻辑转移到了数据库上。那么这意味着一点，数据库的性能开销变大了，那么这就对DBA的要求就更高了。很多中小型公司由于资金问题，并没有聘用专业的DBA，因此他们会选择不用外键，降低数据库的消耗。
相反的，如果该约束逻辑在应用程序中，发现应用服务器性能不够，可以加机器，做水平扩展。如果是在数据库服务器上，数据库服务器会成为性能瓶颈，做水平扩展比较困难。



# 什么是 ER 图？

> 我们做一个项目的时候一定要试着画 ER 图来捋清数据库设计，这个也是面试官问你项目的时候经常会被问道的。

**E-R 图** 也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。 它是描述现实世界关系概念模型的有效方法。 是表示概念关系模型的一种方式。

下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种关系是：1 对 1（1:1）、1 对多（1: N）。

![ER图示例](https://img-blog.csdnimg.cn/img_convert/4717673e36966e0e4b33fccfd753f6ea.png)

我们试着将上面的 ER 图转换成数据库实际的关系模型(实际设计中，我们通常会将任课教师也作为一个实体来处理)：

![关系模型](https://img-blog.csdnimg.cn/img_convert/5897753dfb301dfa3a814ab06e718a5e.png)

# 数据库范式了解吗?

**1NF(第一范式)**

属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。**1NF 是所有关系型数据库的最基本要求** ，也就是说关系型数据库中创建的表一定满足第一范式。

**2NF(第二范式)**

2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。

![第二范式](https://img-blog.csdnimg.cn/img_convert/bd1d31be3779342427fc9e462bf7f05c.png)

一些重要的概念：

- **函数依赖（functional dependency）** ：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。
- **部分函数依赖（partial functional dependency）** ：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）->（姓名），（学号）->（姓名），（身份证号）->（姓名）；所以姓名部分函数依赖与（学号，身份证号）；
- **完全函数依赖(Full functional dependency)** ：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）->（姓名），但是（学号）->(姓名)不成立，（班级）->(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；
- **传递函数依赖** ： 在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。

**3NF(第三范式)**

3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，**基本**上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。



**BCNF**

**BCNF**：消除主属性对主键的部分与传递依赖

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220125123233822.png" alt="image-20220125123233822" style="zoom:80%;" />

如果仔细研究这张表，我们发现主属性为{歌曲编号，歌曲名称，歌手}， {歌曲名称}也依赖于{歌手}则==决定属性集{歌曲编号，歌手}是超键而非候选键==。不满足BCNF。



**4NF(第四范式)**

第四范式是消除表中的多值依赖。以解决信息冗余，达到“一事一地”也就是一对一的关系。

**总结**

- 1NF：属性不可再分，保证==原子性==。
- 2NF：1NF 的基础之上，消除了非主属性对于码（主属性）的部分函数依赖。
- 3NF：3NF 在 2NF 的基础之上，消除了非主属性对于码（主属性）的传递函数依赖 。
- BCNF：消除主属性对主键的部分与传递依赖。
- 4NF：消除表中的多值依赖。

# 什么是存储过程?

我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。

存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。

阿里巴巴 Java 开发手册里要求禁止使用存储过程。

![阿里巴巴Java开发手册: 禁止存储过程](https://img-blog.csdnimg.cn/img_convert/0fa082bc4d4f919065767476a41b2156.png)

# drop、delete 与 truncate 区别？

## 用法不同

- drop(丢弃数据): `drop table 表名` ，直接将表都删除掉，在删除表的时候使用。
- truncate (清空数据) : `truncate table 表名` ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。
- delete（删除数据） : `delete from 表名 where 列名=值`，删除某一列的数据，如果不加 where 子句和`truncate table 表名`作用类似。

truncate 和不带 where 子句的 delete、以及 drop 都会删除表内的数据，但是 **truncate 和 delete 只删除数据不删除表的结构(定义)，执行 drop 语句，此表的结构也会删除，也就是执行 drop 之后对应的表不复存在。**

## 属于不同的数据库语言

truncate 和 drop 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。

**DML 语句和 DDL 语句区别：**

- DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），是开发人员日常使用最频繁的操作。
- DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。

## 执行速度不同

一般来说:drop>truncate>delete（这个我没有设计测试过）。

# 数据库设计通常分为哪几步?

1. **需求分析** : 分析用户的需求，包括数据、功能和性能需求。
2. **概念结构设计** : 主要采用 E-R 模型进行设计，包括画 E-R 图。
3. **逻辑结构设计** : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。
4. **物理结构设计** : 主要是为所设计的数据库选择合适的存储结构和存取路径。
5. **数据库实施** : 包括编程、测试和试运行
6. **数据库的运行和维护** : 系统的运行与数据库的日常维护。

# 自增ID

在MySQL中，数据表的主键一般采用id字段自增的形式。使用自增ID给我们带来不少便捷，但也有不少坏处。

**什么是增ID**：

自增ID是在设计表时如果将id字段的值设置为自增的形式也就是AUTO_INCREMENT，那么当插入一行数据时就无需指定id，数据表会根据前一个id值+1进行填充。指定了AUTO_INCREMENT的列必须要建索引，一般把ID作为主键，这样系统会自动为ID建立索引。

**好处**：

- 自增ID是在设计表时如果将id字段的值设置为自增的形式也就是AUTO_INCREMENT；
- 那么当插入一行数据时就无需指定id，数据表会根据前一个id值+1进行填充；
- 指定了AUTO_INCREMENT的列必须要建索引，一般把ID作为主键，这样系统会自动为ID建立索引；

**坏处**：

- 不具有连续性，表中auto_increment最大值被删除，将不会被重用。就是说会跳号（如果设定的auto_increment_increment是1，那么下一次插入的id值将会从被删除的最大值算起，也就是被删除的最大值+1）；
- 历史数据表的主键id会与数据表的id重复，两张自增id做主键的表合并时，id会有冲突，但如果各自的id还关联了其他表，这就很不好操作；
- 很难处理分布式存储的数据表，尤其是需要合并表的情况下；
- 在系统集成或割接时，如果新旧系统主键不同是数字型就会导致修改主键数据类型，这也会导致其它有外键关联的表的修改，后果同样很严重；

**解决方案**：

**自增ID的替代者UUID自增ID的替代者UUID**

**UUID是指在一台机器上生成的数字，它保证对在同一时空中的所有机器都是唯一的。**

UUID的目的，是让分布式系统中的所有元素，都能有唯一的辨识资讯，而不需要透过中央控制端来做辨识资讯的指定。如此一来，每个人都可以建立不与其它人冲突的UUID。在这样的情况下，就不需考虑数据库建立时的名称重复问题。

**UUID的优点**

- 能够保证独立性，程序可以在不同的数据库间迁移，效果不受影响；
- 保证生成的ID不仅是表独立的，而且是库独立的，这点在你想切分数据库的时候尤为重要；
- 安全性较高；

**UUID的缺点**：

- uuid是无序的，这会严重影响到表的插入性能；
- uuid占的空间大；

# 慢SQL如何优化

## explain使用介绍

**id：**执行编号，标识select所属的行。如果在语句中没子查询或关联查询，只有唯一的select，每行都将显示1。否则，内层的select语句一般会顺序编号，对应于其在原始语句中的位置

**select_type：**显示本行是简单或复杂select。如果查询有任何复杂的子查询，则最外层标记为PRIMARY（DERIVED、UNION、UNION RESUlT）

**table：**访问引用哪个表（引用某个查询，如“derived3”）

**type：**数据访问/读取操作类型（ALL、index、range、ref、eq_ref、const/system、NULL）

**possible_keys：**揭示哪一些索引可能有利于高效的查找

**key：**显示mysql决定采用哪个索引来优化查询

**key_len：**显示mysql在索引里使用的字节数

**ref：**显示了之前的表在key列记录的索引中查找值所用的列或常量

**rows：**为了找到所需的行而需要读取的行数，估算值，不精确。通过把所有rows列值相乘，可粗略估算整个查询会检查的行数。整编：微信公众号，搜云库技术团队，ID：souyunku

**Extra：**额外信息，如using index、filesort等

​      Using filesort表示通过对返回数据进行排序

​      Using temporary表示查询有使用临时表, 一般出现于排序, 分组和多表join的情况, 查询效率不高, 仍需要进行优化，出现临时表的原因还可能是数据量过大使用了临时表进行分组运算

重点关注type，type类型的不同竟然导致性能差六倍！！！

type显示的是访问类型，是较为重要的一个指标，结果值从好到坏依次是：system > const > eqref > ref > fulltext > refornull > indexmerge > uniquesubquery > indexsubquery > range > index > ALL ，一般来说，得保证查询至少达到range级别，最好能达到ref。

**All：**最坏的情况,全表扫描

**index：**和全表扫描一样。只是扫描表的时候按照索引次序进行而不是行。主要优点就是避免了排序, 但是开销仍然非常大。如在Extra列看到Using index，说明正在使用覆盖索引，只扫描索引的数据，它比按索引次序全表扫描的开销要小很多

**range：**范围扫描，一个有限制的索引扫描。key 列显示使用了哪个索引。当使用=、 <>、>、>=、<、<=、IS NULL、<=>、BETWEEN 或者 IN 操作符,用常量比较关键字列时,可以使用 range |

**ref：**一种索引访问，它返回所有匹配某个单个值的行。此类索引访问只有当使用非唯一性索引或唯一性索引非唯一性前缀时才会发生。这个类型跟eq_ref不同的是，它用在关联操作只使用了索引的最左前缀，或者索引不是UNIQUE和PRIMARY KEY。ref可以用于使用=或<=>操作符的带索引的列。

**eq_ref：**最多只返回一条符合条件的记录。使用唯一性索引或主键查找时会发生 （高效）

**const：**当确定最多只会有一行匹配的时候，MySQL优化器会在查询前读取它而且只读取一次，因此非常快。当主键放入where子句时，mysql把这个查询转为一个常量（高效）

**system：**这是const连接类型的一种特例，表仅有一行满足条件。

**Null：**意味说mysql能在优化阶段分解查询语句，在执行阶段甚至用不到访问表或索引（高效）

举例SQL： EXPLAIN select * from student group by  age 

## 解决方案

1. 尽量避免在where子句中对字段进行函数操作，这将导致存储引擎放弃使用索引而进行全表扫描。对于需要计算的值最好通过程序计算好传入而不是在sql语句中做计算

2. group by实质是先排序后分组，也就是分组之前必排序。通过分组的时候禁止排序优化sql 

举例：group by name order by null

3. 使用分组查询、范围查询，而不是全量查询

