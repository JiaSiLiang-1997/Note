[TOC]

# 相关面试题

1. mysql索引【7】

2. [Hash索引](#t1)

3. MyISAM索引底层是什么结构

4. mysql的索引结构，有什么[优点、缺点](#t9)【2】

5. [从联合索引出发，要求画出联合索引B+树索引图](#t6)

6. [联合索引底层数据结构](#t6)

7. [mysql的主键，唯一索引区别，怎么建索引](#t7)；

8. [数据库B+树](#t10)【6】

9. [为什么MySQL不用红黑树](#t11)

10. [为什么选择B+树不选择B树](#t10)【4】

11. [聚簇索引和非聚簇索引的区别](#t2)

12. [innodb中主键索引和非主键索引都是聚簇索引吗](#t7)

13. 为什么会有覆盖索引

    ```
    覆盖索引的使用能够减少树的搜索次数，避免了回表，显著提升了查询性能，因此覆盖索引是一个常用的性能优化手段。
    ```

14. 为什么覆盖索引存在最左匹配原则【2】

15. [索引下推](#t5)

16. [创建索引的原则](#t7)

17. [怎么决定建立哪些索引](#t7)

18. [什么场景需要建立索引，为什么要建立索引？](#t7)【2】

19. 排序数据要建索引吗？范围查询要建索引吗？txt文本数据要建索引吗？

20. [数据库索引失效的情况](#t8)【3】

21. [MySQL中主键是否需要设置为自增？](#t4)

22. mysql为什么不好用模糊查询

# 基础知识

**定义**：**索引是一种用于快速查询和检索数据的数据结构。**

**优点**：<a name="t9"></a>

- 使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。
- 通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。
  避免全表扫描（当走不到索引时，就只能一个一个的去匹配；如果走索引，则可以根据B树来定位）
- 使用索引可以帮助服务器避免排序或者临时表 （叶子节点上的指针，可以有效的支持范围查询；此外叶子节点本身就是根据key进行排序的）
- 索引将随机IO变成顺序IO

**缺点**：

- 创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。
- 索引需要使用物理文件存储，也会耗费一定空间。

**查询慢的主要原因**：MySQL数据存储在**磁盘**，查询数据较慢的原因在于**IO操作**。因此，要提高查询效率，就要提高IO效率。一个方面是**减少IO操作的次数**，另一方面是**减少IO操作的数据量**。

**扩展**：

- **局部性原理**：数据和程序都有聚集成群的倾向，同时之前被访问过的数据很可能再次被查询，空间局部性，时间局部性。
- **磁盘预读**：内存跟磁盘在发生数据交互的时候，一般情况下有一个最小的逻辑单元，称之为**页（datapage**）,页一般由操作系统决定是多大，一般是4k或者8k，而我们在进行数据交互的时候，可以取页的整数倍来进行读取。**INNODB存储引擎**每次读取数据，读取16k。

**如何设计索引**：

- **存储位置**：索引存储在磁盘，查询数据的时候，会优先将索引加载到内存中； 
- **存储信息**：索引在存储时需要存储的信息或字段值为**唯一标识（key ：实际数据行中存储的值）**、**文件地址**和**偏移量（offset）**;
- **数据结构**：需要存储K-V结构的数据，
  - 哈希表；
  - 树（二叉树、BST树、红黑树、AVL树、B树、B+树）；

**扩展**：在MySQL数据中，索引系统并不是按照上述（唯一标识、文件地址、偏移量）进行存储，为什么？ 

- 联机分析处理（OLAP）：对海量历史数据进行分析，产生决策性的影响 **==》** 数据仓库 **==》** Hive

- 联机事务处理（OLTP）：要求在很短的时效内返回对应的结果 **==》** 关系型数据库 **==》** mysql、oracle、db2、...

  在数据仓库（Hive）使用的就是上述（唯一标识、文件地址、偏移量）的数据信息进行存储。

  **思考**：要求在很短的时效内返回对应的结果，假如数据量很大的时候，如果按照上述的存储信息，对应的索引也会很大。如果把该索引从磁盘加载到内存中时，就会又产生**IO操作**的效率问题。**因此，在关系型数据库中，有另一种数据结构对索性进行存储。**

# 索引结构

## Hash索引<a name="t1"></a>

**概念**：基于哈希表实现，只有精确匹配索引所有列的查询才有效。对于每一行数据，存储引擎都会对所有的索引列计算一个哈希码（hash code），哈希码是一个较小的值，并且不同键值的行计算出来的哈希码也不一样。哈希索引将所有的哈希码存储在索引中，同时在哈希表中保存指向每个数据行的指针。

**结构**：

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220128145255746.png" alt="image-20220128145255746" style="zoom: 67%;" />

**存在问题**：

- **哈希冲突**：当发生哈希冲突时，数据散列不均匀，造成空间浪费。而且，当某一条链过长时，会产生大量的线性查询，效率降低；
- **不支持范围查询**：当进行范围查询时，必须要进行逐一遍历；
- **不能利用部分索引键查询**
- **不能利用部分索引键查询**

**优点**：

- **等值查询**速度非常快；

**存储引擎**：

- Memory存储引擎使用的是Hash索引；
- INNODB存储引擎支持自适应Hash；

## 树索引

使用树的索引结构，总体分为两大类：

- 二叉树、BST树、红黑树、AVL树；
- B树、B+树；

**扩展知识点：**

![树的演变过程 (2)](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/%E6%A0%91%E7%9A%84%E6%BC%94%E5%8F%98%E8%BF%87%E7%A8%8B%20(2).jpg)

**存在问题**：如果数据库使用**二叉树、BST树、红黑树、AVL树**做为索引结构，那么**随着数据的插入，发现树的深度会变深，树的深度越深，意味着IO次数越多,景响数据读取的效率**。<a name="t11"></a>

**根本原因**：**IO次数**随树的深度增加的根本原因在于**二叉树、BST树、红黑树、AVL树**的出度均为2。

**解决办法**：将**有序二叉树**转换为**有序的多叉树**。因此，就有了**B树**和**B+树**。

## B树索引

**结构**：

![image-20220128183201632](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220128183201632.png)

## B+树索引

<a name="t10"></a>

**结构**：

![image-20220128185836662](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220128185836662.png)

**思考**：在创建索引时，用int还是varchar?

MySQL默认使用InnoDB存储引擎，创建索引时底层使用的是B+Tree，通常B+Tree一共有3层或者4层。

假如是三层B+Treee，假如每层能容纳16kb。 每一对指针p和key占了10个字节，每个data占了1kb，那么这个B+Tree到底能存储多少条数据呢?

答案就是：
第一层：16 * 1024/10
第二层：16 * 1024/10
第三层：16/1
最终就是：16 * 1024/10 * 16 * 1024/10 * 16/1≈4.2 * 10^8条数据，
这个数据量已经很大了，因此大部分情况，3层B+Tree就足够了。

**由图可知：第一层和第二层是不存放data的。因此想要增加存储的数据条数，就要减少key占的空间**，因此若用varchar表示key的长度是多少个字节，如果varchar小于4个字节，那么就用varchar，如果varchar大于4个字节，那么就用int。

**注意**：在B+Tree 上有两个头指针，一个指向根节点，另一个指向关键宇最小的叶子节点，而且所有叶子节点(即数据节点)之间是一种链式
环结构。因此可以对B+Tree进行两种查找运算：一种是对于主键的范围查找和分页查找，另一种是从根节点开始。进行随机查找。

# 聚簇索引与非聚簇索引

<a name="t2"></a>

**MyISAM存储引擎和innoDB存储引擎均使用B+树实现的索引结构**，但两者实现的方式又有所不同。

- **MyISAM存储引擎**：叶子节点存储**key**和**数据值的内存地址**，即索引结构和数据分开存放，这种索引称为**非聚集（簇）索引**；
- **InnoDB存储引擎**：叶子节点存储**key**和**完整的数据值**，即索引结构和数据一起存放，这种索引称为**聚集（簇）索引**；

|                |    innoDB存储引擎    | MyISAM存储引擎 |
| :------------: | :------------------: | :------------: |
|  **聚簇索引**  |  只能有一个聚簇索引  |       无       |
| **非聚簇索引** | 可以有多个非聚簇缩影 | 只有非聚簇索引 |

## InnoDB存储引擎索引结构

![image-20220128201413904](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220128201413904.png)

**注意**：

1. InnoDB是通过B+ Tree结构对主键创建索引，然后叶子节点中存储记录，如果没有**主键**，那么会选择**唯一键**， 如果没有唯一键， 那么会自动生成一个6字节的row_id来作为主键；
2. 如果创建索引的键是其他字段，那么在叶子节点中存储的是该记录的主键，然后再通过主键索引找到对应的记录，叫做**[回表](#t3)**；

InnoDB存储引擎，插入数据时，必须要包含一个索引的key值，这个key值可以是**主键**，如果没有主键，就是**唯一键**，如果没有唯一键，则会**自动生成6字节的row_id**。

**扩展**：创建表示，主键是否需要自增？<a name="t4"></a>

**答案**：B+树的插入，可能会引起树分裂操作。因此，设置主键是自增，那么每一次都是在主键索引的最后增加，当一页写满，就会自动开辟一个新页，不会有主键索引树分裂这一步，效率会比随机主键高很多。这也是很多建表规范要求主键自增的原因。

## MyISAM存储引擎索引结构

![image-20220128202552493](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220128202552493.png)

## 回表

假设有一张表，有id、name、age、gender四个字段，id是主键，name是索引列。

```sql
SELECT * FROM TABLE WHERE name="zhangsan"
```

这个数据库表有两个索引，以id为key值的索引为主键索引，以name为key值的索引为唯一索引。其中name建立的B+树索引中，叶子节点数据域存放的是key值。因此，这条语句先走name索引查询key值，再通过key值走主键索引找到对应的数据记录。这条查询语句走了2颗B+树，这种现象称为**回表**。<a name="t3"></a>

## 索引覆盖

假设有一张表，有id、name、age、gender四个字段，id是主键，name是索引列。

```sql
SELECT id,name FROM TABLE WHERE name="zhangsan" 
```

根据name可以直接查询id，name两个列的值，直接返回即可，不需要从聚簇索引查询任何数据，此时叫做**索引覆盖**。

## 最左匹配原则

假设有一张表，有id、name、age、gender四个字段，id是主键，name是索引列。

|           | **主键索引** | **组合索引（联合索引）** |
| :-------: | :----------: | :----------------------: |
| **KEY值** |      id      |       (name, age)        |

**最左匹配原则**：组合索引使用的时候必须先匹配name，再匹配age。

```sql
SELECT * FROM TABLE WHERE name="zhangsan" AND age=10	// 匹配成功，索引生效
SELECT * FROM TABLE WHERE name="zhangsan"				// 匹配成功，索引生效
SELECT * FROM TABLE WHERE age=10						// 匹配失败，索引失效
SELECT * FROM TABLE WHERE age=10 AND name="zhangsan"	// 匹配成功，索引生效
```

**注意**：第4条查询语句能使用索引的原因在于，MySQL内部的优化器会进行对应的调整。

**组合索引结构**：

<a name="t6"></a>

![image-20220128220629039](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220128220629039.png)

## 索引下推

<a name="t5"></a>

假设有一张表，有id、name、age、gender四个字段，id是主键，(name, age)是联合索引。

```sql
SELECT * FROM TABLE WHERE name="zhangsan" AND age=15
```

- 没有**索引下推**之前：先根据name从存储引擎中获取符合规则的数据，然后在server层对age进行过滤。
- 有**索引下推**之后：根据(name, age)两个条件来从存储引擎中获取对应的数据。

**补充**：MySQL的三层架构

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220128221134174.png" alt="image-20220128221134174" style="zoom: 80%;" />



# 索引分类及应用场景

<a name="t7"></a>

## 主键索引(Primary Key)

数据表的主键列使用的就是主键索引。

一张数据表有只能有一个主键，并且主键不能为 null，不能重复。

在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。

## 二级索引(辅助索引)

**二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。**

唯一索引，普通索引，前缀索引等索引属于二级索引。

1. **唯一索引(Unique Key)** ：唯一索引也是一种约束。**唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。** 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。
2. **普通索引(Index)** ：**普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。**
3. **前缀索引(Prefix)** ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小，
   因为只取前几个字符。
4. **全文索引(Full Text)** ：全文索引主要是为了检索大文本数据中的关键字的信息，是目前搜索引擎数据库使用的一种技术。Mysql5.6 之前只有 MYISAM 引擎支持全文索引，5.6 之后 InnoDB 也支持了全文索引。

## 需要创建索引

- **主键自动建立主键索引**；

- **不为 NULL 的字段** ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。
- **被频繁查询的字段** ：我们创建索引的字段应该是查询操作非常频繁的字段。
- **被作为条件查询的字段** ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。
- **频繁需要排序的字段** ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
- **被经常频繁用于连接的字段** ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。

## 创建索引的注意事项

**1.选择合适的字段创建索引：**

- **不为 NULL 的字段** ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。
- **被频繁查询的字段** ：我们创建索引的字段应该是查询操作非常频繁的字段。
- **被作为条件查询的字段** ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。
- **频繁需要排序的字段** ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。
- **被经常频繁用于连接的字段** ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。

**2.被频繁更新的字段应该慎重建立索引。**

虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。
如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。

**3.尽可能的考虑建立联合索引而不是单列索引。**

因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。

**4.注意避免冗余索引** 。

冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。

**5.考虑在字符串类型的字段上使用前缀索引代替普通索引。**

前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。

## 使用索引的一些建议

- 对于中到大型表索引都是非常有效的，但是特大型表的话维护开销会很大，不适合建索引
- 避免 where 子句中对字段施加函数，这会造成无法命中索引。
- 在使用 InnoDB 时使用与业务无关的自增主键作为主键，即使用逻辑主键，而不要使用业务主键。
- 删除长期未使用的索引，不用的索引的存在会造成不必要的性能损耗 MySQL 5.7 可以通过查询 sys 库的 schema_unused_indexes 视图来查询哪些索引从未被使用
- 在使用 limit offset 查询缓慢时，可以借助索引来提高性能

# 索引失效的情况

<a name="t8"></a>

- like 以%开头，索引无效；当like前缀没有%，后缀有%时，索引有效；

  ```sql
  SELECT * FROM emp WHERE ename LIKE "%";		// 索引失效
  SELECT * FROM emp WHERE ename LIKE "%L";	// 索引失效
  SELECT * FROM emp WHERE ename LIKE "S%";	// 索引有效
  ```

- or语句前后没有同时使用索引。当or左右查询字段只有一个是索引，该索引失效，只有当or左右查询字段均为索引时，才会生效；

  ```sql
  // empno、sal为索引列
  SELECT * FROM emp WHERE empno=7369 OR ename="SMITH";	// 索引失效
  SELECT * FROM emp WHERE empno=7369 OR sal=800;			// 索引有效
  ```

- 组合索引，不是使用第一列索引（不符合最左匹配原则），索引失效。

  ```sql
  // (ename, empno, job)为组合索引
  SELECT * FROM emp WHERE ename="SMITH" AND empno=7369 AND job="CLERK";	// 索引有效
  SELECT * FROM emp WHERE empno=7369 AND job="CLERK";		// 索引失效
  ```

- 数据类型出现隐式转化。如varchar不加单引号的话可能会自动转换为int型，使索引无效，产生全表扫描。

  ```sql
  // job为varchar类型
  SELECT * FROM emp WHERE job="123";	// 索引有效
  SELECT * FROM emp WHERE job=123;	// 索引失效
  ```

- 在索引列上使用 IS NULL 或 IS NOT NULL操作，索引不一定失效！！！

- 在索引字段上使用not，<>，!=。不等于操作符是永远不会用到索引的，因此对它的处理只会产生全表扫描。 

  优化方法： key<>0 改为 key>0 or key<0；

  ```sql
  SELECT * FROM emp WHERE ename!="SMITHI";	// 索引失效
  ```

- 对索引字段进行计算操作、字段上使用函数。

  ```sql
  // (ename,empno,sal)为组合索引
  SELECT * FROM emp WHERE LEFT(ename, 2)="SMITH";		// 索引失效
  ```

- 当全表扫描速度比索引速度快时，mysql会使用全表扫描，此时索引失效。

# MySQL 如何为表字段添加索引？

1.添加 PRIMARY KEY（主键索引）

```sql
ALTER TABLE `table_name` ADD PRIMARY KEY ( `column` )
```

2.添加 UNIQUE(唯一索引)

```sqlite
ALTER TABLE `table_name` ADD UNIQUE ( `column` )
```

3.添加 INDEX(普通索引)

```sql
ALTER TABLE `table_name` ADD INDEX index_name ( `column` )
```

4.添加 FULLTEXT(全文索引)

```sql
ALTER TABLE `table_name` ADD FULLTEXT ( `column`)
```

5.添加多列索引

```sql
ALTER TABLE `table_name` ADD INDEX index_name ( `column1`, `column2`, `column3` )
```

