

# 一 面向对象思想

## 1.1 概述

**面向过程**：当需要实现一个功能的时候，每一个具体的步骤都要亲力亲为，详细处理每一个细节。

**面向对象**：当需要实现一个功能的时候，不关心具体的步骤，而是找一个已经具有该功能的人，来帮我做事儿。

代码示例：

```java
public class Main() {
    public static void main(String[] args) {
        int[] array = {10, 20, 30, 40, 50};
        
        // 要求打印格式为：[10, 20, 30, 40, 50]
        // 面向过程的方法实现，每一个过程都要亲力亲为。
        System.out.print("[");
        for (int i = 0; i < array.length; i++) {
            if (i == array.length - 1) {
                System.out.print(array[i] + "]");
            }else{
                System.out.print(array[i] + ", ");
            } 
        }
        
        // 面向对象的方法实现
        // 找一个JDK给我们提供好的Arrays类
        // 其中有一个toString方法，直接就能把数组变成想要的格式的字符串。
        System.out.println(Array.toString(array));
    }
}
```



## 1.2 举例

洗衣服: 

- 面向过程：把衣服脱下来 --> 找一个盆 --> 放点洗衣粉 --> 加点水 --> 浸泡10分钟 --> 揉一揉 --> 清洗衣服 --> 拧干 --> 晾起来

- 面向对象：把衣服脱下来 --> 打开全自动洗衣机 --> 扔衣服 --> 按钮 --> 晾起来

区别:

- 面向过程：强调步骤。

- 面向对象：强调对象，这里的对象就是洗衣机。

## 1.3 类和对象的关系

 什么是类？

- 类：是一组相关**属性**和**行为**的集合。可以看成是一类事物的模板，使用事物的属性特征和行为特征来描述该类事物。

现实中，描述一类事物：

- **属性**：就是该事物的状态信息。
- **行为**：就是该事物能够做什么。

举例：小猫

​		属性：名字、体重、年龄、颜色。

​		行为：走、跑、叫。

什么是对象？

- 对象：是一类事物的具体体现。对象是类的一个实例（对象并不是找个女朋友），必然具备该类事物的属性和行为。

现实中，一类事物的一个实例：一只小猫。

举例：一只小猫。

​		属性：tom、5kg、2 years、yellow。

​		行为：喵喵叫、蹦跶的跑。

类与对象的关系：

1. 类是一类事物的描述，是**抽象的**。
2. 对象是一类事物的实例，是**具体的**。
3. **类是对象的模板，对象是类的实体**。

## 1.4 类的定义

事物与类的对比：

现实世界的一类事物：

​		**属性**：事物的状态信息。

​		**行为**：事物能够做什么。

Java中用class描述事物也是如此：

​		**成员变量**：对应事物的属性。

​		**成员方法**：对应事物的行为。

类的定义格式：

```java
public class ClassName {
    // 成员变量
    // 成员方法
}
```

**成员类**：就是定义类的成员，包括**成员变量**和**成员方法**。

**成员变量**：和以前定义变量几乎是一样的。只不过位置发生了改变。在类中，方法外。

**成员方法**：和以前定义方法几乎是一样的。只不过把static去掉。

## 1.5 对象的创建及使用

通常情况下，一个类并不能直接使用，需要根据类创建一个对象，才能使用。

1. 导包

```java
import 包名称.类名称;
```

2. 创建

```java
类名称 对象名 = new 类名称();
```

3. 使用

```java
对象名.成员变量名
对象名.成员方法名(参数)
```

# 二 封装性

## 2.1 概述

封装性在Java当中的体现：

1. 方法就是一种封装
2. 关键字private也是一种封装

封装就是将一些细节信息隐藏起来，对外界不可见。



## 2.2 private关键字的作用以及使用

问题描述：定义Person的年龄时，无法阻止不合理的数值被设置进来。

解决方案：用private关键字将需要保护的成员变量进行修饰。

一旦使用了private进行修饰，那么本类当中仍可以随意访问。

但是，超出了本类范围之外就不能再直接访问了。

间接访问private成员变量，就是定义一对儿Getter/Setter方法。

命名规则：setXXX或者getXXX

对于Getter来说，不能有参数，返回值类型和成员变量对应；

对于Setter来说，不能有返回值，参数类型和成员变量对应。



举例：

```java
public class Person {
    String name;
    private int age;
    
    // 这个成员方法，专门用于向age设置数据
    public void setAge(int num) {
        age = num;
    }
    
    // 这个成员方法，专门获取age的数据
    public int getAge() {
        return age;
    }
}
```



# 三 继承性

## 3.1 概述

继承是多态的前提，如果没有继承，就没有多态。

继承主要解决的就是：**共性抽取**

[![6WzI6x.png](https://s4.ax1x.com/2021/03/19/6WzI6x.png)](https://imgtu.com/i/6WzI6x)

继承关系当中的特点：

1. 子类可以拥有父类的"内容"；
2. 子类还可以拥有自己专有的内容。



## 3.2 格式

在继承的关系中，"子类就是一个父类"。也就是说，子类可以被当作父类看待。

例如：父类是员工，子类是讲师，那么"讲师就是一个员工"。	关系：is-a

定义父类的格式：（一个普通的类定义）

```java
public class 父类名称 {
    // 属性和方法
}
```

定义子类的格式：

```java
public class 子类名称 extends 父类名称 {
	// 属性和方法
}
```

代码示例：

```java
// 定义一个父类：员工
public class Employee {
    public void method() {
        System.out.println("方法执行！");
    }
}
```

```java
// 定义一个员工的子类：讲师
public class Teacher extends Employee {
}
```

```java
// 定义员工的一个子类：助教
public class Assistant extends Employee {
}
```

```java
public class ExampleExtends {
    public static void main(String[] args) {
        // 创建一个子类对象：讲师
        Teacher teacher = new Teacher();
        // 子类继承了父类的方法，可以直接调用
   		teacher.method(); 
        // 创建一个子类对象：助教
        Assistant assistant = new Assistant();
        // 子类继承了父类的方法，可以直接调用
        assistant.method();
    }
}
```



## 3.3 成员变量的访问特点

代码示例：

```java
// 定义一个父类
public class Fu {
    int numFu = 10;
    int num = 100;
    public void methodFu() {
        System.out.println(num); // 使用的是本类当中的，不会向下找子类的，输出：100
    }
}
```

```java
// 定义一个子类
public class Zi extends Fu {
    int numZi = 20;
    int num = 200; // 与父类中的属性重名
    public void methodZi() {
        System.out.println(num); // 因为本类中有num，故使用的是本类中的num，输出：200
    }
}
```

```java
public class ExampleEntendsFiled {
    public static void main(String[] args) {
        /*不重名访问*/
        Fu fu = new Fu(); // 创建父类对象
        System.out.println(fu.numFu); // 只能使用父类的东西，没有任何子类内容
        
        Zi zi = new Zi();
        System.out.println(zi.numFu); // 10
        System.out.println(zi.numZi); // 20
        
        /*重名访问*/
        System.out.println(zi.num); // 重名的情况，等号左边是Zi，故优先使用子类的属性，输出：200
        System.out.println(zi.abc); // 子父类中都没有，就编译报错
        
        zi.methodZi(); // 这个方法是子类的，就优先用子类的，输出：200
        zi.methodFu(); // 这个方法是父类当中定义的，使用的是父类的num，输出：100
    }
}
```

在父子类的继承关系中，如果成员变量重名，则创建子类对象时，访问有两种方式：

1. 直接通过子类对象访问成员变量；

   ​		等号左边是谁，就优先用谁，没有则向上找；

2. 间接通过成员方法访问成员变量；

   ​		该方法属于谁，就优先用谁，没有则向上找。

   

## 3.4 区分三种子类方法中重名的问题

代码示例：

```java
public class Fu {
    int num = 10;
}
```

```java
public class Zi extends Fu {
    int num = 20;
    
    public void method() {
        int num = 30;
        System.out.println(num); // 30，局部变量
        System.out.println(this.num) // 20，本类的成员变量
        System.out.println(super.num) // 10，父类的成员变量
    }
}
```

```java
public class ExampleExtendsField {
    public static void main(String[] args) {
        Zi zi = new Zi();
        zi.method(); // 输出：30 20 10
    }
}
```

访问方法：

|    局部变量    | 直接写成员变量名 |
| :------------: | :--------------: |
| 本类的成员变量 | this.成员变量名  |
| 父类的成员变量 | super.成员变量名 |



## 3.5 成员方法的访问特点

代码示例：

```java
public class Fu {
    public void methodFu() {
        System.ou.println("父类方法执行！");
    }
    public void method() {
        System.out.println("父类重名方法执行！");
    }
}
```

```java
public class Zi extends Fu {
    public void methodZi() {
        System.out.println("子类方法执行！");
    }
    public void method() {
        System.out.println("子类方法执行！");
    }
}
```

```java
public class ExampleExtendsMethod {
    public static void main(String[] args) {
        Zi zi = new Zi();
        
        zi.methodFu(); // 输出：父类方法执行！
        zi.methodZi(); // 输出：子类方法执行！
        
        zi.method(); // 创建的是子类对象，所以优先使用子类的重名方法，如果没有就向上查找
    }
}
```

在父子类的继承关系中，创建子类对象，访问成员方法的规则：

​		创建的对象是谁，就优先用谁，如果没有则向上找。

注意事项：无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的。



## 3.6 重写（Override）

概念：在继承关系当中，方法的名称一样，参数列表也一样。

**重写（Override）**：方法的名称一样，参数列表**也一样**。（覆盖、覆写）

**重载（Overload）**：方法的名称一样，参数列表**不一样**。

方法覆盖重写的特点：创建的是子类对象，则优先用子类方法。

方法覆盖重写的注意事项：

1. **必须保证父子类之间方法的名称相同，参数列表也相同**。

   @override：写在方法前面，用来检测是不是有效的正确覆盖重写。注：这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。

2. 子类方法的返回值必须**小于等于**父类方法的返回值范围。

   扩展提示：`java.lang.Object`类是所有类的公共最高父类（祖宗类），`java.lang.String`就是`Obeject`的子类。

3. 子类方法的权限必须**大于等于**父类方法的权限修饰符。

   扩展提示：`public` > `protected` > `(default)` > `private`	注： `(default)` 不是关键字`default`，而是什么都不写，留空。

代码示例：

```java
public class Fu {
    public void method() {       
    }
}
```

```java
public class Zi extends Fu {
    @override
    public void method() { 
        // 与父类的成员方法重名，进行覆盖重写。 
    }
}
```



代码示例：

[![6f1w4J.png](https://s4.ax1x.com/2021/03/19/6f1w4J.png)](https://imgtu.com/i/6f1w4J)

```java
// 老款手机
public class Phone {
    public void call() {
        System.out.println("打电话");
    }
    public void send() {
        System.out.println("发短信");
    }
    public void show() {
        System.out.println("显示号码");
    }
}
```

```java
// 定义一个新手机，使用老手机作为父类
public class NewPhone extends Phone {
    @override
    public void show() {
        /*方式一*/
        System.out.println("显示号码");
        System.out.println("显示姓名");
        System.out.println("显示头像");
        
        /*方式二（推荐）*/
        super.show(); // 把父类的show()方法拿过来重复利用。
        System.out.println("显示头像");
        System.out.println("显示头像");
    }
}
```



## 3.7 构造方法的访问特点

继承关系中，父子类构造方法的访问特点：

1. 子类构造方法当中有一个默认隐含的"`super()`"调用，所以一定是先调用的父类构造，后执行的子类构造。
2. 子类构造可以通过`super`关键字来子类构造调用父类重载。
3. `super`的父类构造调用，必须是子类构造方法的**第一个**语句。不能一个子类构造调用多次`super`构造。

总结：

​	子类必须调用父类构造方法，不写则赠送`super()`；写了则用写的指定的`super`调用，`super`只能有一个，还必须是第一个。

```java
public class Fu {
    public Fu() {
        System.out.println("父类无参构造！")
    }
    public Fu(int num) {
        System.out.println("父类有参构造！");
    }
}
```

```java
public class Zi extends Fu {
    public Zi() {
        // super(); // 默认的是不带参数的
        // super(10); // 可以指定参数，来调用父类重载的构造方法
        System.out.println("子类构造方法！");
    }
}
```

```java
public class ExampleConstructor {
    public static void main(String[] args) {
        Zi zi = new Zi();
    }
    /*
    输出结果：
    父类构造方法！
	子类构造方法！
    */
}
```



# 三 接口

## 4.1 概述

生活中举例：接口就是一种**公共的规范标准**。只要符合规范标准，就可以大家通用。

 面向对象：接口就是多个类的公共规范，接口是一种引用的数据类型，最重要的内容就是其中的：抽象方法。

## 4.2 格式

```java
public interface 接口名称 {
    // 接口内容
}
```

备注：换成了关键字`interface`之后，编译生成的字节码文件仍然是：`.java` --> `.class`

如果是Java 7，那么接口中可以包含有：（1）常量；（2）抽象方法；

如果是Java 8，还可以额外包含有：（3）默认方法；（4）静态方法；

如果是Java 9，还可以额外包含有：（5）私有方法；

## 4.3 定义

在任何版本的Java中，接口都能定义抽象方法：

格式：

```java
public abstract 返回值类型 方法参数(参数列表);
```

代码示例：

```java
public interface ExampleInterfaceAbstract {
    // 定义一个抽象方法
    public abstract void methodAbs1();
    // 也是一个抽象方法
    abstract void methodAbs2();
    // 也是一个抽象方法
    public void methodAbs3();
    // 也是一个抽象方法
    void methodAbs4();
}
```

注意事项：

1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：`public abstract`
2. 这两个关键字修饰符，可以选择性地省略。
3. 方法的三要素，可以随意定义。

## 4.4 使用步骤

1. 接口不能直接使用，必须有一个"实现类"来"实现"该接口。

2. 接口的实现类必须覆盖重写接口中所有的抽象方法。

   实现：去掉`abstract`关键字，加上方法体大括号。

3. 创建实现类的对象，进行使用。

格式：

```java
public class 实现类名称 implements 接口名称 {
    // ...
}
```

代码示例：

```java
// 定义一个接口实现类
public class ExampleInterfaceAbstractImpl implements ExampleInterfaceAbstract {
    @Override
    public void methodAbs1() {
        System.out.println("这是第一个方法！");
    }
    
    @Override
    public void methodAbs2() {
        System.out.println("这是第二个方法！");
    }
    
    @Override
    public void methodAbs3() {
        System.out.println("这是第三个方法！");
    }
    
    @Override
    public void methodAbs4() {
        System.out.println("这是第四个方法！");
    }
}
```

```java
public class ExampleInterface {
    public static void main(String[] args) {
        // 创建实现类的对象使用
        ExampleInterfaceAbstractImple impl = new ExampleInterfaceAbstractImple();
        impl.methodAbs1(); // 输出：这是第一个方法！
        impl.methodAbs2(); // 输出：这是第二个方法！
        impl.methodAbs3(); // 输出：这是第三个方法！
        impl.methodAbs4(); // 输出：这是第四个方法！
    }
}
```

注意事项：

1. 如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。

## 4.5 默认方法的定义

从Java 8开始，接口里允许定义默认方法。

1. 接口的默认方法，可以通过接口实现类对象，直接调用。
2. 接口的默认方法，也可以被接口实现类进行覆盖重写。

格式：

```java
public default 返回值类型 方法名称(参数列表) { 
    方法体 
} // 默认方法是可以有方法体的！！！
```

备注：接口当中的默认方法，可以解决接口升级的问题。

## 4.6 默认方法的使用

代码示例：

```java
// 定义一个接口
public interface ExampleInterfaceDefault {
    // 抽象方法
    public abstract void mehtodAbs();
    
    /*
    	如果新添加一个功能（使用抽象方法），因为所有的接口实现类已经投入使用，
    	不方便对新的抽象方法进行重写，那么可以使用默认方法，进行升级。
    */
    // 定义一个默认方法
    public default void mehotdDefault() { // 这里的public可以省略，default不可以省略
        System.out.println("这是新添加的默认方法！");
    }
    
    
}
```

```java
// 接口实现类A
public class ExampleInterfaceDefaultImplA implements ExampleInterfaceDefault {
    @Override
    public void methodAbs() {
        System.out.println("实现了抽象方法，AAA");
    }
}
```

```java
// 接口实现类B
public class ExampleInterfaceDefaultImplB implements ExampleInterfaceDefault {
    @Override
    public void methodAbs() {
        System.out.println("实现了抽象方法，BBB");
    }
    
    @Override
    public void methodDefault() {
        System.out.println("实现类B覆盖重写了接口的默认方法！");
    }
}
```

```java
public class ExampleInterface implements ExampleInterfaceDefault {
    public static void main(String[] args) {
        // 创建了实现类A对象
        MyInterfaceDefaultA a = new MyInterfaceDefaultA();
        a.methodAbs(); // 调用抽象方法，实际运行的是右侧实现类。 输出：实现了抽象方法，AAA
        a.methodDefault();// 实现类中没有实现，但实现类继承了接口中的默认方法。 输出：这是新添加的默认方法！
        
        // 创建了实现类B对象
        MyInterfaceDefaultB b = new MyInterfaceDefaultB();
        b.methodAbs(); // 输出：实现了抽象方法，BBB
        b.methodDefault();// 输出：实现类B覆盖重写了接口的默认方法！
    }
}
```

## 4.7 静态方法的定义

从Java 8开始，接口当中允许定义静态方法。

格式：

```java
public static 返回值类型 方法名称(参数列表) {
    方法体
}
```

提示：就是将`abstract`或者`default`换成`static`即可，带上方法体。

## 4.8 静态方法的使用

**注意事项**：不能通过接口实现类的对象来调用接口当中的静态方法。

使用方法：

```java
接口名称.静态方法名(参数);
```

代码示例：

```java
// 定义一个接口
public interface ExampleInterfaceStatic {
    public static void methodStatic() {
        System.out.println("这是接口的静态方法！");
    }
}
```

```java
// 定义一个接口实现类
public class ExampleInterfaceStaticImpl extends ExampleInterfaceStatic {
     
}
```

```java
public class ExampleInterface {
    public static void main(String[] args) {
        // 定义一个接口实现类对象
        ExampleInterfaceStaticImpl impl = new ExampleInterfaceStaticImple();
        
        // 错误写法！！！
        impl.methodStatic();
          
        // 正确写法：直接用接口名称进行调用
        ExampleInterfaceStaticImpl.methodStatic(); // 输出：这是接口的静态方法！
    }
}
```

**回顾**：静态跟对象没关系，只与类、接口有关系。

## 4.9 私有方法的定义

问题描述：

​		我们需要抽取一个共有方法，来解决两个默认方法之间重复代码的问题。但是这个共有方法不应该让实现类使用，应该是私有化的。

解决方案：

从Java 9开始，接口当中允许定义私有方法。

1. 普通私有方法，解决多个**默认方法**之间重复代码的问题。
2. 静态私有方法，解决多个**静态方法**之间重复代码的问题。

格式：

```java
// 普通私有方法，解决多个默认方法之间重复代码的问题。
private 返回值类型 方法名称(参数列表) {
    方法体
}
// 静态私有方法，解决多个静态方法之间重复代码的问题。
private static 返回值类型 方法名称(参数列表) {
    方法体
}
```

## 4.10 私有方法的使用

代码示例：

```java
/*
	解决方案一：在接口中定义一个新的默认方法，用来实现共有方法（代码重复）。
	存在弊端：使用默认方法来解决的话，接口实现类会继承这个共有方法，而我们的目的是不让实现类使用，故此矛盾。
*/
public interface ExampleInterfacePrivateA {
    public default void methodDefault1() {
        System.out.println("默认方法1");
        methodCommon();
    }
    public default void methodDefault2() {
        System.out.println("默认方法1");
        methodCommon();   
    }
    
    public default void methodCommon() {
        System.out.println("AAA");
        System.out.println("BBB");
        System.out.println("CCC");  
    }
}
```

```java
/*
	解决方案二：在接口中定义一个普通私有方法，用来实现接口中默认方法的共有方法（代码重复）。
*/
public interface ExampleInterfacePrivateB {
    public default void methodDefault1() {
        System.out.println("默认方法1");
        methodCommon();
    }
    public default void methodDefault2() {
        System.out.println("默认方法2");
        methodCommon();   
    }
    
    // 普通私有方法
    private void methodCommon() {
        System.out.println("AAA");
        System.out.println("BBB");
        System.out.println("CCC");  
    }
}
```

```java
/*
	在接口中定义一个静态私有方法，用来实现接口中静态方法的共有方法（代码重复）。
*/
public interface ExampleInterfacePrivateB {
    public static void methodDefault1() {
        System.out.println("静态方法1");
        methodStaticCommon();
    }
    public static void methodDefault2() {
        System.out.println("静态方法2");
        methodStaticCommon();   
    }
    // 静态私有方法
    private static void methodStaticCommon() {
        System.out.println("AAA");
        System.out.println("BBB");
        System.out.println("CCC");  
    }
}
```

## 4.11 常量的定义与使用

接口当中也可以定义"成员变量"，但是必须使用`public`、`static`、`final`三个关键字进行修饰。

从效果上看，这其实就是接口的**常量**。

备注：一旦使用final关键字进行修饰，说明不可改变。

注意事项：

1. 接口当中的常量，可以省略`public`、`static`、`final`，注意：**不写也照样是这样**。
2. 接口当中的常量，必须进行赋值，不能不赋值。
3. 接口中常量的名称，使用完全大写的字母，用下划线进行分割。（推荐命名规则）

格式：

```java
public static final 数据类型 常量名称 = 数据值;
```

代码示例：

```java
public interface ExampleInterfaceConst {
    // 这其实就是一个常量，一旦赋值，不可以修改
    public static final int NUM_OF_MY_CLASS = 10;
}
```

```java
public class ExampleInterface {
    public static void main(String[] args) {
        // 访问接口当中的常量
        System.out.println(ExampleInterfaceConst.NUM_OF_MY_CLASS); // 输出：10
    }
}
```

## 4.12 内容小结

在Java 9+版本中，接口的内容可以有：

1. 成员变量其实是常量，格式：

```java
[public] [static] [final] 数据类型 常量名称 = 数据值；
```

​	注意：常量必须进行赋值，而一旦赋值不能改变。常量名称完全大写，用下划线进行分割。

2. 接口中最重要的就是抽象方法，格式：

```java
[public] [abstract] 返回值类型 方法名称(参数列表);
```

​	注意：实现类必须覆盖重写接口所有的抽象方法，除非实现类是抽象类。

3. Java 8+开始，接口里允许定义默认方法，格式：

```java
[public] default 返回值类型 方法名称(参数列表) {
    方法体;
}
```

​	注意：默认方法也可以被覆盖重写。

4. 从Java 8开始，接口里允许定义静态方法，格式：

```java
[public] static 返回值类型 方法名称(参数列表) {
    方法体;
}
```

​	注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法。

5. 从Java 9开始，接口里允许定义私有方法，格式：

```java
普通私有方法： private 返回值类型 方法名称(参数列表) {
    方法体;
}
静态私有方法： private static 返回值类型 方法名称(参数列表) {
    方法体;
}
```

注意：`private`的方法只有接口自己才能调用，不能被实现类或别人使用。

## 4.13 多接口

使用接口的时候，需要注意：

1. 接口是没有静态代码块或者构造方法的。
2. 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。
3. 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。
4. 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。
5. 如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。
6. 一个类直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。

格式：

```java
public interface ExampleInterfaceA {
    public static void methodA();
    public static void methodAbs();
    public default void methodDefault() {
        System.out.println("默认方法AAA");
    }
}
```

```java
public interface ExampleInterfaceB {
    public static void methodB();
    public static void methodAbs(); // 接口A中的抽象方法重名了！
    public default void methodDefault() {
        System.out.println("默认方法BBB");
    }
}
```

```java
public class ExampleInterfaceImpl implements ExampleInterfaceA, ExampleInterfaceB {
    // 覆盖重写所有抽象方法
    @Override
    public void methodA() {
        System.out.println("覆盖重写了A方法");
    }
    @Override
    public void methodB() {
        System.out.println("覆盖重写了B方法");
    }
    @Override
    public void methodAbs() {
        System.out.println("覆盖重写了AB接口都有的抽象方法");
    }
    @Override
    public void methodDefault() {
        System.out.println("对多个接口当中冲突的默认方法进行了覆盖重写")
    }
}
```

## 4.14 接口之间的多继承

1. 类与类之间是单继承的，直接父类只有一个。
2. 类与接口之间是多实现的，一个类可以实现多个接口。
3. 接口与接口之间是多继承的。

代码示例：

```java
// 接口A
public interface ExampleInterfaceA {
    public abstract void methodA();
    public abstract void methodCommon();
    public default void methodDefault() {
        System.out.println("AAA");
    }
}
```

```java
// 接口B
public interface ExampleInterfaceB {
    public abstract void methodB();
    public abstract void methodCommon();
    public default void methodDefault() {
        System.out.println("BBB");
    }
}
```

```java
// 定义一个新的接口，继承接口A和接口B
public interface ExampleInterface extends ExampleInterfaceA, ExampleInterfaceB {
    public abstract void method();
    // 这个新接口中共有几个方法呢？ 4个
    // methodA()，来源于接口A
    // methodB()，来源于接口B
    // methodCommon()，同时来源于接口A和B
    // method()，来源于自己
    
    // 在接口A和接口B中有重名的默认方法，那么在他们的继承接口中，必须对该重名的默认方法进行覆盖重写。
    @Override
    public default void methodDefault() {
         
    }
}
```

```java
public class ExampleRelations {
    
}
```

注意事项：

1. 多个父接口当中的抽象方法如果重复，没关系。（因为接口中的抽象方法没有方法体，只有到接口实现类中才会对其覆盖重写。）

2. 多个父接口当中的默认方法如果重复，那么子接口必须对默认方法进行覆盖重写。（而且带着`default`关键字）

   

# 五 多态

## 5.1 概述

`extends`继承或者`implements`实现，是多态性的前提。  

举例：

小明是一个学生（学生形态），但同时也是一个人（人类形态）。

小明是一个对象，这个对象既有学生形态，也有人类形态。一个对象拥有多种形态，这就是：**对象的多态性**。

## 5.2 格式

代码当中体现多态性，其实就是一句话：**父类引用指向子类对象**。

```java
父类名称 对象名 = new 子类名称();
接口名称 对象名 = new 实现类名称();
```

  代码示例：

```java
public class Fu {
    public void method() {
        System.out.println("父类方法");
    }
    public void methodFu {
        System.out.println("父类特有方法");
    }
}
```

```java
public class Zi extends Fu {
    @Override
    public void method() {
        System.out.println("子类方法");
    }
}
```

```java
public class ExampleMulti {
    public static void main(String[] args) {
        // 使用多态的写法
        // 左侧父类的引用，指向了右侧子类的对象
        Fu obj = new Zi();
        obj.method(); // 输出：子类方法
        obj.methodFu(); // 输出：父类特有方法
    }
}
```

## 5.3 成员变量的访问特点

访问成员变量的两种方式：

1. 直接通过**对象名称**访问成员变量：看等号**左边**是谁，优先用谁，没有则**向上**查找。
2. 间接通过**成员方法**访问成员变量：看该方法**属于**谁，优先用谁，没有则**向上**查找。

代码示例：

```java
public class Fu {
    int num = 10;
    public void showNum() {
        System.out.println(num);
    }
}
```

```java
public class Zi extends Fu {
    int num = 20;
}
```

```java
public class ExampleMultiField {
    public static void main(String[] args) {
        // 使用多态的写法，父类引用指向子类对象
        Fu obj = new Zi();
        System.out.println(obj.num); // 输出：10 
        // 子类没有覆盖重写，就是父：10
        // 子类如果覆盖重写，就是子，20
        obj.showNum();
    }
}
```

##  5.4 成员方法的访问特点

在多态的代码当中，成员方法的访问规则是：

​		看`new`的是谁，就优先用谁，没有则向上找。

口诀：

​		成员变量：编译看左边，运行看左边。

​		成员方法：编译看左边，运行看右边。

代码示例：

```java
public class Fu {
    public void method() {
        System.out.println("父类方法");
    }
    public void methodFu {
        System.out.println("父类特有方法")
    }
}
```

```java
public class Zi extends Fu {
    @Override
    public void method() { 
    }
    public void methodZi() {
        System.out.println("子类特有方法")
    }
}
```

```java
public class ExampleMultiMethod {
    public class void main(String[] args) {
        Fu obj = new Zi();
        // 运行看右，父类都有该方法，编译通过，实际运行时看右边new的是谁就用谁
        obj.method(); // 父子都有，优先用子（new谁用谁）
        obj.methodFu(); // 父有子没有，向上查找
        // 编译看左，左边是Fu，Fu当中没有methodZi方法，所有编译报错。
        obj.methodZi(); // 错误写法！！！
    }
}
```

## 5.5 多态的好处

<center><img src="https://z3.ax1x.com/2021/03/22/6IGVHI.png" alt="6IGVHI.png" style="zoom: 50%" /></center>

代码示例:

```java
// 定义员工类
public class Employee {
    public abstract void work();
}
```

```java
// 定义讲师类，继承员工类
public class Teacher extends Employee {
    @Override
    public void work() {
        System.out.println("上课");
    }
}
```

```java
// 定义助教类，继承员工类
public class Assistant extends Employee {
    @Override
    public void work() {
        System.out.println("辅导");
    }
}
```

```java
public class ExampleMulti {
    public static void main(String[] args) {
        // 方式一：不使用多态的情况
        Teacher one = new Teacher();
        Assistant two = new Assistant();
        one.work();
        two.work();
        
        // 方式二：使用多态的情况
        Employee one = new Teacher();
        Employee two = new Assistant();
        one.work();
        two.work();
    }
}
```

好处：

​		无论右边`new`的时候换成哪个子类对象，等号左边调用方法都不会变化。

## 5.6 对象的向上转型

 对象的向上转型，其实就是多态写法。（父类引用指向了子类对象）

格式：

```java
父类名称 对象名 = new 子类名称();
```

含义：右侧创建一个子类对象，把它当作父类来看待使用。

注意事项：向上转型一定是安全的，是从小范围转向了大范围。

举例：将一只猫（子类，小范围）看作一只动物。（父类，大范围）

## 5.7 对象的向下转型 

向上转型一定是安全的，没有问题的，正确的。但是存在一个弊端：对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。

解决方案：用对象的向下转型 **[还原]** 。

对象的向下转型，其实是一个 **[还原]** 的动作。

格式：

```java
子类名称 对象名 = (子类名称)父类对象;
```

含义：将父类对象，**[还原]** 成为本来的子类对象。

注意事项：

1. 必须保证对象本来创建的时候，是子类A，才能向下转型成为子类A。（因为一个父类可能有多个子类）
2. 如果对象创建的时候是子类A，现在要强制向下转型成为子类B，就会报错（编译正常，运行报错）。

类似于：

```java
int num = (int) 10.0; // 可以
int num = (int) 10.5; // 不可以，精度损失。
```



扩展：**如何才能知道一个父类引用的对象，本来是什么子类？**

格式：

```java
对象 instanceof 类名称
```

这将会得到一个`boolean`值结果，也就是判断前面的对象能不能当作后面类型的实例。

代码示例：

```java
public class ExampleInstanceof {
    public static void main(String[] args) {
        Animal animal = new Cat(); // 本来是一只猫
        animal.eat();
        
        // 如果希望调用子类特有方法，需要向下转型
        // 判断一下父类引用animal本来是不是Dog
        if (animal instanceof Dog) {
            Dog dog = (Dog) animal;
            dog.watchHouse();
        }
        // 判断一下animal本来是不是Cat
        if (animal instanceof Cat) {
            Cat cat = (Cat) animal;
            cat.catchMouse();
        }
    }
} 
```



思考一下：**为什么需要使用上下转型，是否多余？**

想象一下这样一个场景，当你的女朋友寂寞时，她需要一个动物，无论是什么动物都行。

即定义一个方法，其参数是父类引用对象，那么对于其任意子类对象向上转型都可以作为其参数。如下：`giveMeAPet() `方法

代码示例：

```java
public class ExampleInstanceof {
    public static void main(String[] args) {
        Animal animal = new Cat(); // 本来是一只猫
        animal.eat();
        
        // 如果希望调用子类特有方法，需要向下转型
        
    }
    // 判断一下父类引用animal本来是不是Dog
        if (animal instanceof Dog) {
            Dog dog = (Dog) animal;
            dog.watchHouse();
        }
        // 判断一下animal本来是不是Cat
        if (animal instanceof Cat) {
            Cat cat = (Cat) animal;
            cat.catchMouse();
        }
    public static void giveMeAPet(Animal animal) { // 传谁都行！！！ 
        // 判断一下父类引用animal本来是不是Dog
        if (animal instanceof Dog) {
            Dog dog = (Dog) animal;
            dog.watchHouse();
        }
        // 判断一下animal本来是不是Cat
        if (animal instanceof Cat) {
            Cat cat = (Cat) animal;
            cat.catchMouse();
        }
    }
} 
```

## 5.8 案例

### 5.8.1 笔记本电脑

笔记本电脑(laptop)通常具备使用USB设备的功能。在生产时，笔记本都预留了可以插入USB设备的USB接口，但具体是什么USB设备，笔记本厂商并不关心，只要符合USB规格的设备都可以。
定义USB接口，具备最基本的开启功能和关闭功能。鼠标和键盘要想能在电脑上使用，那么鼠标和键盘也必须遵守USB规范，实现USB接口，否则鼠标和键盘的生产出来也无法使用。

### 5.8.2 案例分析

进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘

- USB接口：包含打开设备功能，关闭设备功能。
- 笔记本类：包含开机功能、关机功能、使用USB设备功能。
- 鼠标类：要实现USB接口，并具备点击的方法。
- 键盘类：要实现USB接口，具备敲击的方法。

<center><img src="https://z3.ax1x.com/2021/03/22/6oK1UO.png" alt="6IGVHI.png" style="zoom: 50%" /></center>

```java
// 定义USB接口
public interface USBDevice {
    // 打开设备
    public abstract void openDevice();
    // 关闭设备
    public abstract void closeDevice();
}
```

```java
// 定义鼠标类
public class Mouse implements USBDevice {
    @Override
    public void openDevice() {
        System.out.println("打开鼠标功能");
    }
    @Override
    public void cloaseDevice() {
        System.out.println("关闭鼠标功能");
    }
    public void Click() {
        System.out.println("鼠标点击一次");
    }
}
```

```java
// 定义键盘类
public class Keyboard implements USBDevice {
    @Override
    public void openDevice() {
        System.out.println("打开键盘功能");
    }
    @Override
    public void closeDevice() {
        System.out.prinltn("关闭键盘功能");
    }
    public void knock() {
        System.out.println("键盘敲击一次");
    }
}
```

```java
// 定义电脑类
public class Computer {
    public void startingUp() {
        System.out.println("电脑已开机");
    }
    public void turnOff() {
        System.out.println("电脑已关机");
    }
    // 使用USB设备，使用接口作为方法的参数
    public void useUsbDevice(USB usb) {
        usb.openDevice(); // 打开设备
        if (usb instanceof Mouse) { // 一定要先判断
            Mouse mouse = (Mouse) usb; // 向下转型
            mouse.click();
        } else if (usb instanceof Keyboard) { // 先判断
            Keyboard keyboard = (Keyboard) usb; // 向下转型
            keyboard.type();
        }
        usb.closeDevice(); // 关闭设备
    }
}
```

```java
public class DemoMain {
    public static void main(String[] args) {
        // 首先创建一个笔记本电脑
        Computer computer = new Computer();
        // 开机
        computer.powerOn();
        // 准备一个鼠标，供电脑使用
        // Mouse mouse = new Mouse();
        // 首先进行向上转型
        USB usbMouse = new Mouse(); // 多态写法
        // 参数是USB，正好传递进去的就是USB鼠标
        computer.useDevice(usbDevice);
        // 创建一个键盘
        Keyboard keyboard = new Keyboard(); // 没有使用多态写法
        // 方法参数是USB类型，传递进去的是实现类对象
        computer.usbDevice(keyboard); // 正确写法!!!  也发生了向上转型
       	computer.usbDevice(new Keyboard()); // 也是正确写法
        // 关机
        computer.powerOff();
    }
    public 
}
```



# 六 内部类

## 6.1 概念

如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。

例如：身体和心脏的关系。又如：汽车和发动机的关系。

分类：

1. 成员内部类
2. 局部内部类（包含匿名内部类）

## 6.2 成员内部类的格式

```java
修饰符 class 外部类名称 {
    修饰符 class 内部类名称 {
        // ... 
    }
    // ...
}
```

注意：内用外，随意访问；外用内，需要内部类对象。

代码示例：

```java
public class Body { // 外部类
    public class Heart { // 成员内部类
        // 内部类的方法
        public void beat() {
            System.out.println("心脏跳动：蹦蹦蹦！");
            System.out.println("我叫：" + name); // 正确写法!
        }
    }
    // 外部类的成员变量
    private String name;
    
    public String getName() {
        return name;
    }
    
    public void setName() {
        this.name = name;
    }
    
    // 外部类的方法
    public void methodBody() {
        System.out.println("外部类的方法");
        Heart heart = new Heart();
        heart.beat();
    }
}
```

## 6.3 成员内部类的使用

如何使用成员内部类？有两种方式：

1. 间接方式：在外部类的方法当中，使用内部类；然后`main`只是调用外部类的方法。
2. 直接方式，公式：

```java
外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称()
```

代码示例：

```java
public class ExampleInnerClass {
    public static void main(String[] args) {
        // 方式一：间接方式
        Body body = new Body(); // 外部类的对象
        // 通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart
        body.methodBody();
        
        // 方式二：直接方式
        Body.Heart heart = new Body().new Heart();
    }
}
```

## 6.4 内部类的同名变量访问

如果出现了重名现象，那么格式是：

```java
外部类名称.this.外部类成员变量
```

代码示例：

```java
public class Outer {
    int num = 10; // 外部类的成员变量
    public class Inner {
        int num = 20; // 内部类的成员变量
        public void methodInner() {
            int num = 30; // 内部类方法的局部变量
            System.out.println(num); // 局部变量，就近原则
            System.out.println(this.num); // 内部类的成员变量
            System.out.println(super.num); // 报错，因为 内部类不是继承外部类的
            System.out.println(Outer.this.num); // 外部内的成员变量
        }
    }
}
```

```java
public class ExampleInnerClass {
    public static void main(String[] args) {
        // 外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();
        Outer.Inner obj = new Outer().new Inner();
        obj.methodInner();
    }
}
```

## 6.5 局部内部类的定义与格式

如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。

"局部"：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。

格式：

```java
修饰符 class 外部类名称 {
    修饰符 返回值类型 外部类方法名称(参数列表) {
        class 局部内部类名称 {
            // ...
        }
    }
}
```

代码示例：

```java
public class Outer {
    public void methodOuter() {
        class Inner { // 局部内部类
            int num = 10;
             public void methodInner() {
                 System.out.println(num); // 输出：10
             }
        }
        Inner inner = new Inner();
        inner.methodInner();
    }
}
```

```java
public class ExampleMain {
    public static void main(String[] args) {
        Outer obj = new Outer(); 
        obj.methodOuter(); 
    }
}
```

## 6.6 局部内部类的final问题

局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是**[有效final的]**

备注：从java8+ 开始，只要局部变量事实不变，那么final关键字可以省略。

原因：

1. new出来的对象在堆内存当中。
2. 局部变量是跟着方法走的，在栈内存当中。
3. 方法运行结束之后，立刻出栈，局部变量就会立刻消失。
4. 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。

代码示例：

```java
public class Outer {
    public void methodOuter() {
        final int num = 10; // 所在方法的局部变量
        
        class Inner {
            public void methodInner() {
                System.out.println(num);
            }
        }
    }
}
```

## 6.7 匿名内部类【重点】

如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】

格式：

```java
接口名称 对象名 = new 接口名称() {
    // 覆盖重写所有抽象方法
};
```

代码示例：

```java
public interface Interface {
    public abstract void method(); // 抽象方法
}
```

```java
public class InterfaceImpl implements Interface {
    @Override
    public void method() {
        System.out.println("实现类覆盖重写了方法");
    }
}
```

```java
public class Main() {
    public static void main(String[] args) {
        InterfaceImpl obj = new InterfaceImpl();
        obj.method();
        
        // 使用匿名内部类，大括号里算是一个匿名内部类，但不是匿名对象（有对象名）
        Interface objA = new Interface() {
            @Override
            public void method() {
                System.out.println("匿名内部类实现了方法！");
            }
        }
        objA.method();
        
        // 使用了匿名内部类，而且省略了对象名称，也是匿名对象
        new Interface() {
            @Override
            public void method() {
                System.out.println("匿名内部类实现了方法！")
            }
        }.method();
    }
}
```

 注意事项：

对格式"new 接口名称( ) { // 覆盖重写所有抽象方法 }"进行解析：

1. new 代表创建对象的动作；
2. 接口名称就是匿名内部类需要实现哪个接口；
3. {...} 这才是匿名内部类的内容。

另外还要注意几点问题：

1. 匿名内部类，在**创建对象**的时候，只能使用唯一一次。

   如果希望多次创建对象，而且类的内容一样的话，那么就必须使用单独定义的实现类了。

2. 匿名对象，在**调用方法**的时候，只能调用一次。

   如果希望同一个对象，调用多次方法，那么必须给对象起个名字。

3. 匿名内部类是省略了**实现类或者子类**，但是匿名对象是省略了**对象名称**。

   强调：匿名内部类和匿名对象不是一回事儿！！！



# 七 抽象

## 7.1 定义

如果父类当中的方法不确定如何进行{ }方法体实现，那么这就应该是一个抽象方法。

<center><img src="https://z3.ax1x.com/2021/03/25/6LKhWV.png" alt="6LKhWV.png" border="0" /></center>

## 7.2 格式

抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。

抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。

代码示例：

```java
public abstract class Animal {
    // 这是一个抽象方法，代表吃东西，但是具体吃什么（大括号的内容）不确定。
    public abstract void eat() {
    }
    
    // 这是普通的成员方法
    public void normalMethod() {
    }
}
```

## 7.3 使用

1. 不能直接创建new抽象类的对象；

2. 必须使用一个子类来继承抽象父类；

3. 子类必须覆盖重写抽象父类当中所有的抽象方法。

   覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。

4. 创建子类对象进行使用。

```java
public class Cat extends Animal {
    @Override
    public void eat {
        System.out.println("猫吃鱼！")
    }
}

public class Dog extends
```

```java
public class Main() {
    public static void main(String[] args) {
        Animal animal = new Animal(); // 错误写法，不能直接创建抽象类对象。
        
        Cat cat = new Cat();
        cat.eat; // 输出：猫吃鱼！
    }
}
```

注意事项：

1. 抽象类不能创建对象，如果创建，编译无法通过而报错，只能创建其非抽象子类的对象。

   理解：假设创建了抽象类的对象，调用抽象方法，而抽象方法没有具体的方法体，没有意义。

2. 抽象类中，可以有构造方法，是供子类创建对象时，初始化父类成员使用的。

   理解：子类构造方法中，有默认的super()，需要访问父类构造方法。

   

3. 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定时抽象类。

   理解：未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。

4. 抽象的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。

   理解：假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。



# 八 扩展

## 8.1 构造方法

构造方法是专门用来创建对象的方法，当我们通过关键字new来创建对象时，其实就是在调用构造方法。

格式：

```java
public 类名称(参数类型 参数名称) {
    方法体
}
```

注意事项：

1. 构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样。
2. 构造方法不要写返回值类型，连void都不写。
3. 构造方法不能return一个具体的返回值。
4. 如果没有编写任何构造方法，那么编译器将会默认创建一个构造方法，没有参数，方法体什么事情都不做。
5. 一旦编写了至少一个构造方法，那么编译器将不再默认创建一个构造方法。
6. 构造方法也是可以重载的。（重载：方法名称相同，参数列表不同）

一个标准的类通常要拥有下面四个组成部分：

1. 所有的成员变量都要使用private关键字修饰。
2. 为每一个成员变量编写一对儿Getter/Setter方法。
3. 编写一个无参数的构造方法。
4. 编写一个全参数的构造方法。

## 8.2 匿名对象

创建对象的标准格式：

```java
类名称 对象名 = new 类名称();
```

匿名对象就是只有右边的对象，没有左边的名字和赋值运算符。

```java
new 类名称();	
```

代码示例：

```java
public Example {
    public static void main(String[] args) {
        // 创建对象的标准格式
        Person one = new Person();
        one.name = "迪丽热巴";
		
        // 匿名对象
        new Person().name = "古力娜扎";
        
    }
}
```

注意事项：匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。

使用建议：如果确定有一个对象只需要使用唯一的一次，就可以使用匿名对象。

匿名对象作为方法的参数

代码示例：

```java
public class Example {
    public static void main(String[] args) {
        // 普通使用方式
        Scanner sc = new Scanner(System.in);
        int num = sc.nextInt();
        
        // 匿名对象的方式
        int num = new Scanner(System.in).nextInt();
        
        // 使用一般写法传入参数
        Scanner sc = new Scanner(System.in);
        methodParam(sc);
        
        // 使用匿名对象来进行传参
        methodParam(new Scanner(System.in));
        
        // 通过匿名对象作为方法的返回值进行调用
        Scanner sc = methodReturn();
        int num = sc.nextInt();
        System.out.println("输入的是：" + num);
    }
    
    public static void methodParam(Scanner sc) {
        int num = sc.nextInt();
        System.out.println("输入的是：" + num);
    }
    
    // 匿名对象作为方法的返回值
    public static Scanner methodReturn() {
        // 普通使用方式
        Scanner sc = new Scanner(System.in);
        return sc;
        
        // 匿名对象方式
        return new Scanner(System.in);
    }
}
```

## 8.3 this关键字

代码示例：

```java
public class Person {
    String name; // 我自己的名字
    
    // 参数name是对方的名字
    // 成员变量name是自己的名字
    public void sayHello(String name) {
        System.out.println(name + "，你好！我是" + name); // 方法参数和成员变量重名
    }
}
```

当方法的局部变量和类的成员变量重名的时候，根据“就近原则”，优先使用局部变量。

如果需要访问本类当中的成员变量，需要使用格式：

```java
this.成员变量
```

上述举例代码正确示例：

```java
public class Person {
    String name; // 我自己的名字
    
    // 参数name是对方的名字
    // 成员变量name是自己的名字
    public void sayHello(String name) {
        System.out.println(name + "，你好！我是" + this.name); // 通过this区分
    }
}
```

注意：

​		通过谁调用的方法，谁就是this。

this关键字的三种用法：

1. 在本类的成员方法中，访问本类的成员变量。
2. 在本类的成员方法中，访问本类的另一个成员方法。
3. 在本类的构造方法中，访问本类的另一个构造方法。

在第三种用法当中要注意：

1. this(...)调用也必须是构造方法的第一个语句，唯一一个。
2. super和this两种构造调用，不能同时使用。

代码示例：

```java
public class FU {
    int num = 30;
}
```

```java
public class Zi extends Fu {
    int num = 20;
    public Zi() {
        super(); // 错误！！！这一行不再赠送。
        this(123); // 本类的无参构造，调用本类的有参构造。
    }
    public Zi(int n) {
        
    } 
    public void showNum() {
        int num = 10;
        System.out.println(num); // 局部变量
        System.out.println(this.num); // 本类中的成员变量
        Syytem.out.println(super.num); // 父类中的成员变量
    }
    public void methodA() {
        System.out.printlN("AAA");
    }
    public void methodB() {
        methodA();
        this.methodA(); // 完全等效
        System.out.println("BBB");
    }
}
```

## 8.4 super关键字

super关键字的用法有三种：

1. 在子类的成员方法中，访问父类的成员变量。
2. 在子类的成员方法中，访问父类的成员方法。
3. 在子类的构造方法中，访问父类的构造方法。

代码示例：

```java
public class Fu {
    int num = 10;
    public void method() {
        System.out.println("父类方法");
    }
}
```

```java
public class Zi extends Fu {
    int num = 20;
    // 默认存在
    public Zi() {
        super();
    }
    public void methodZi() {
        System.out.println(num); // 本类（子类）中的成员变量，输出：20
        System.out.println(this.num); // 父类中的成员变量，输出：10
    }
    public void method() {
        System.out.println("子类方法");
    }
}
```

内存图：

<center><a href="https://imgtu.com/i/c98J8f"><img src="https://z3.ax1x.com/2021/03/29/c98J8f.png" alt="c98J8f.png" border="0" /></a></center>

## 8.5 static关键字

<center><img src="https://z3.ax1x.com/2021/03/27/cSuGlR.png" alt="cSuGlR.png" border="0" /></center>

### 8.5.1 修饰成员变量

如果一个成员变量使用了static关键字，那么这个变量不再属于对象自己，而是属于所在的类。多个对象共享同一份数据。

代码示例：

```java
public class Student {
    private int id; // 学号
	private String name; // 姓名
    private int age; // 年龄
    static String room; // 所在教室
    public static int idCounter = 0; // 学号计数器，每当new了一个新对象的时候，计数器++
    public Student() {
        thid.id = ++idCounter;
    }
    public Student(String name, int age) {
        this.name = name;
        this.age = age;
        this.id = ++idCounter;
    }
    public int getId() {
        return id;
    }
    public void setId(int id) {
        this.id = id;
    }
    public String getName() {
        return name;
    }   
    public void setName(String name) {
        this.name = name;
    } 
    public int getAge() {
        return age;
    }  
    public void setAge(int age) {
        this.age = age;
    }  
}
```

```java
public class ExampleStaticField {
    public static void main(String[] args) {
        Student one = new Student("郭靖", 19);
        one.room = "101教室";
        Student two = new Student("黄蓉", 16);
        System.out.println("姓名：" + one.getName() + "，年龄：" + one.getAge() + "，教室：" + one.room + "，学号：" + one.getId); // 输出：姓名：郭靖，年龄：19，教室：101教室，学号：1
        System.out.println("姓名：" + two.getName() + "，年龄：" + two.getAge() + "，教室：" + two.room + "，学号：" + two.getId); // 输出：姓名：黄蓉，年龄：16，教室：101教室，学号：2
    }
}
```

### 8.5.2 修饰成员方法

一旦使用了static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。

如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。

如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。

无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。

静态变量：类名称.静态变量

静态方法：类名称.静态方法(参数列表)

```java
public class  MyClass {
    int num; // 成员变量
    static int numStatic; // 静态变量
    public void method() {
        System.out.println("这是一个普通的成员方法。");
        // 成员方法可以访问成员变量
        System.out.println(num);
        // 成员方法可以访问静态变量
        System.out.println(numStatic);
    }
    public static void methodStatic() {
        System.out.println("这是一个静态方法。");
        // 静态方法可以访问静态变量
        System.out.println(numStatic);
        // 静态方法不可以访问非静态变量（成员变量）
        System.out.println(num); // 错误写法！！！ 编译不通过
        
        System.out.println(this); // 错误写法！！！ 会强制转换成 类名称.静态方法名
    }
}
```

```java
public class Main {
    public static void main(String[] args) {
        MyClass obj = new MyClass(); // 首先创建对象
        // 然后才能使用没有static关键字的内容
        obj.method();
        
        // 对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。
        obj.methodStatic(); // 正确，不推荐，这种写法再编译之后也会被javac翻译成为  类名称.静态方法名
        MyClass.methodStatic(); // 正确（推荐）
        
        // 对于本来当中的静态方法，可以省略类名称
        myMethod();
        Main.myMethod(); // 完全等效
    }
    
    public static void MyMethod() {
        System.out.println("自己的方法！");
    }
}
```

注意事项：

1. 静态只能访问静态，不能直接访问非静态。

   原因：因为在内存当中是**先有**的静态内容，**后有**的非静态内容。————“先人不知道后人，但是后人知道先人。”

2. 静态方法当中不能用this。

   原因：this代表当前对象，通过谁调用的方法，谁就是当前对象。

### 8.5.3 内存图

<center><a href="https://imgtu.com/i/cS1EqI"><img src="https://z3.ax1x.com/2021/03/27/cS1EqI.png" alt="cS1EqI.png" border="0" /></a></center>

### 8.5.4 静态代码块

格式：

```java
public class 类名称 {
    static {
        // 静态代码块的内容
    }
}
```

特点：当第一用到本类时，静态代码块执行唯一的一次。

静态的内容总是优先非静态，所以静态代码块比构造方法先执行。

典型用途：用来一次性对静态成员变量进行赋值。

## 8.6 final关键字

### 8.6.1 概述与四种用法

概述：final关键字代表最终的，不可改变的。

常用的四种用法：

1. 可以用来修饰一个类。
2. 可以用来修饰一个方法。
3. 可以用来修饰一个局部变量。
4. 可以用来修饰一个成员变量。

### 8.6.2 修饰类

当final关键字用来修饰一个类的时候，格式：

```java
public final class 类名称 {
    // ...
}
```

含义：当前这个类不能有任何的子类，即不能被继承。

注意：一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写。（因为没有子类）

### 8.6.3 修饰方法

当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。

格式：

```java
修饰符 final 返回值类型 方法名称(参数列表) {
    // 方法体
}
```

注意事项：

对于类和方法来说，abstract 和 final 关键字不能同时使用，因为矛盾。

### 8.6.4 修饰局部变量

一旦使用final用来修饰局部变量，那么这个变量就不能进行更改。“一次赋值，终生不变”

对于基本类型来说，不可变说的是变量当中的数据不可改变。

对于引用类型来说，不可变说的是变量当中的地址值不可改变。

### 8.6.5 修饰成员变量

对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变的。

1. 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。
2. 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。
3. 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。

## 8.7 四种权限修饰符

Java中有四种权限修饰符：

|                        | public | protected | (default) | private |
| ---------------------- | :----: | :-------: | :-------: | :-----: |
| 同一个类（我自己）     |  YES   |    YES    |    YES    |   YES   |
| 同一个包（我领居）     |  YES   |    YES    |    YES    |   NO    |
| 不同包子类（我儿子）   |  YES   |    YES    |    NO     |   NO    |
| 不同包非子类（陌生人） |  YES   |    NO     |    NO     |   NO    |

注意事项：(default)并不是关键字“default”，而是根本不写。

