#  一 概述

在 数组 中，可以通过索引访问**随机**元素。 但是，某些情况下，可能需要限制处理的顺序。

在本 LeetBook 中，将会介绍两种不同的处理顺序，**先入先出**和**后入先出**；以及两个相应的线性数据结构，**队列**和**栈**。

我们将详细介绍每个数据结构的定义，实现和内置函数。更多地关注这两种数据结构的实际应用。

完成后，你将：

1. 了解 FIFO 和 LIFO 处理顺序的原理；
2. 实现这两个数据结构；
3. 熟悉内置的队列和栈结构；
4. 解决基本的队列相关问题，尤其是 `BFS`；
5. 解决基本的栈相关问题；
6. 理解在使用 `DFS` 和其他 `递归` 算法来解决问题时，系统栈是如何发挥作用的。



# 二 队列：先入先出的数据结构

本章节中，我们将首先介绍**先入先出（`FIFO`）**及其在队列中的工作方式。

本章的目的是帮助你：

1. 理解 FIFO 和队列的**定义**；
2. 能够自己**实现**队列；
3. 熟悉**内置队列结构**；
4. 使用队列来解决简单的问题。



## 2.1 先入先出的数据结构

![image-20210825153958419](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210825153958419.png)

在 FIFO 数据结构中，将**首先处理添加到队列中的第一个元素**。

如上图所示，队列是典型的 FIFO 数据结构。插入（insert）操作也称作入队（enqueue），新元素始终被添加在**队列的末尾**。 删除（delete）操作也被称为出队（dequeue)。 你**只能移除第一个元素**。

**示例**：

入队与出队：

<img src="https://pic.leetcode-cn.com/44b3a817f0880f168de9574075b61bd204fdc77748d4e04448603d6956c6428a-出入队.gif" alt="img" style="zoom:50%;" />



## 2.2 队列-实现

为了实现队列，我们可以使用动态数组和指向队列头部的索引。

如上所述，队列应支持两种操作：入队和出队。入队会向队列追加一个新元素，而出队会删除第一个元素。 所以我们需要一个索引来指出起点。

这是一个供你参考的实现：

```java
// "static void main" must be defined in a public class.

class MyQueue {
    // store elements
    private List<Integer> data;         
    // a pointer to indicate the start position
    private int p_start;            
    public MyQueue() {
        data = new ArrayList<Integer>();
        p_start = 0;
    }
    /** Insert an element into the queue. Return true if the operation is successful. */
    public boolean enQueue(int x) {
        data.add(x);
        return true;
    };    
    /** Delete an element from the queue. Return true if the operation is successful. */
    public boolean deQueue() {
        if (isEmpty() == true) {
            return false;
        }
        p_start++;
        return true;
    }
    /** Get the front item from the queue. */
    public int Front() {
        return data.get(p_start);
    }
    /** Checks whether the queue is empty or not. */
    public boolean isEmpty() {
        return p_start >= data.size();
    }     
};

public class Main {
    public static void main(String[] args) {
        MyQueue q = new MyQueue();
        q.enQueue(5);
        q.enQueue(3);
        if (q.isEmpty() == false) {
            System.out.println(q.Front());
        }
        q.deQueue();
        if (q.isEmpty() == false) {
            System.out.println(q.Front());
        }
        q.deQueue();
        if (q.isEmpty() == false) {
            System.out.println(q.Front());
        }
    }
}
```

**缺点**：

上面的实现很简单，但在某些情况下效率很低。 随着起始指针的移动，浪费了越来越多的空间。 当我们有空间限制时，这将是难以接受的。

![image-20210825155256405](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210825155256405.png)

让我们考虑一种情况，即我们只能分配一个最大长度为 5 的数组。当我们只添加少于 5 个元素时，我们的解决方案很有效。 例如，如果我们只调用入队函数四次后还想要将元素 10 入队，那么我们可以成功。

但是我们不能接受更多的入队请求，这是合理的，因为现在队列已经满了。但是如果我们将一个元素出队呢？

![image-20210825155317435](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210825155317435.png)


实际上，在这种情况下，我们应该能够再接受一个元素。



## 2.3 循环队列

此前，我们提供了一种简单但低效的队列实现。

更有效的方法是使用循环队列。 具体来说，我们可以使用**固定大小的数组**和**两个指针**来指示起始位置和结束位置。 目的是**重用**我们之前提到的**被浪费的存储**。

让我们通过一个示例来查看循环队列的工作原理。 你应该注意我们**入队**或**出队**元素时使用的策略。

![jsl](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/jsl.gif)



**设计循环队列**：

设计你的循环队列实现。 循环队列是一种线性数据结构，其操作表现基于 FIFO（先进先出）原则并且队尾被连接在队首之后以形成一个循环。它也被称为“环形缓冲器”。

循环队列的一个好处是我们可以利用这个队列之前用过的空间。在一个普通队列里，一旦一个队列满了，我们就不能插入下一个元素，即使在队列前面仍有空间。但是使用循环队列，我们能使用这些空间去存储新的值。

你的实现应该支持如下操作：

- `MyCircularQueue(k)`: 构造器，设置队列长度为 k 。
- `Front`: 从队首获取元素。如果队列为空，返回 -1 。
- `Rear`: 获取队尾元素。如果队列为空，返回 -1 。
- `enQueue(value)`: 向循环队列插入一个元素。如果成功插入则返回真。
- `deQueue()`: 从循环队列中删除一个元素。如果成功删除则返回真。
- `isEmpty()`: 检查循环队列是否为空。
- `isFull()`: 检查循环队列是否已满。

**示例**：

```tex
MyCircularQueue circularQueue = new MyCircularQueue(3); // 设置长度为 3
circularQueue.enQueue(1);  // 返回 true
circularQueue.enQueue(2);  // 返回 true
circularQueue.enQueue(3);  // 返回 true
circularQueue.enQueue(4);  // 返回 false，队列已满
circularQueue.Rear();  // 返回 3
circularQueue.isFull();  // 返回 true
circularQueue.deQueue();  // 返回 true
circularQueue.enQueue(4);  // 返回 true
circularQueue.Rear();  // 返回 4
```

**提示**：

- 所有的值都在 0 至 1000 的范围内；
- 操作数将在 1 至 1000 的范围内；
- 请不要使用内置的队列库。

**代码实现**：

```java
public class MyCircularQueue {
    private int[] data;
    int head;
    int tail;

    public MyCircularQueue(int k) {
        this.data = new int[k + 1];
        this.head = 0;
        this.tail = 0;
    }

    public boolean enQueue(int value) {
        if (isFull()) {
            return false;
        } else {
            data[tail] = value;
            tail = (tail + 1) % data.length;
            return true;
        }
    }

    public boolean deQueue() {
        if(isEmpty()) {
            return false;
        } else {
            head = (head + 1) % data.length;
            return true;
        }
    }

    public int Front() {
        if (isEmpty()) {
            return -1;
        }  else {
            return data[head];
        }
    }

    public int Rear() {
        if(isEmpty()) {
            return -1;
        } else {
            return data[(tail - 1 + data.length) % data.length];
        }

    }

    public boolean isEmpty() {
        return tail == head;
    }

    public boolean isFull() {
        return (tail + 1) % data.length == head;
    }
}

/**
 * Your MyCircularQueue object will be instantiated and called as such:
 * MyCircularQueue obj = new MyCircularQueue(k);
 * boolean param_1 = obj.enQueue(value);
 * boolean param_2 = obj.deQueue();
 * int param_3 = obj.Front();
 * int param_4 = obj.Rear();
 * boolean param_5 = obj.isEmpty();
 * boolean param_6 = obj.isFull();
 */
```



## 2.4 循环队列-实现

**思路**：

在循环队列中，我们使用一个`数组`和两个指针（`head` 和 `tail`）。 `head` 表示队列的起始位置，`tail` 表示队列的结束位置。

**代码实现**：

```java
class MyCircularQueue {
    
    private int[] data;
    private int head;
    private int tail;
    private int size;

    /** Initialize your data structure here. Set the size of the queue to be k. */
    public MyCircularQueue(int k) {
        data = new int[k];
        head = -1;
        tail = -1;
        size = k;
    }
    
    /** Insert an element into the circular queue. Return true if the operation is successful. */
    public boolean enQueue(int value) {
        if (isFull() == true) {
            return false;
        }
        if (isEmpty() == true) {
            head = 0;
        }
        tail = (tail + 1) % size;
        data[tail] = value;
        return true;
    }
    
    /** Delete an element from the circular queue. Return true if the operation is successful. */
    public boolean deQueue() {
        if (isEmpty() == true) {
            return false;
        }
        if (head == tail) {
            head = -1;
            tail = -1;
            return true;
        }
        head = (head + 1) % size;
        return true;
    }
    
    /** Get the front item from the queue. */
    public int Front() {
        if (isEmpty() == true) {
            return -1;
        }
        return data[head];
    }
    
    /** Get the last item from the queue. */
    public int Rear() {
        if (isEmpty() == true) {
            return -1;
        }
        return data[tail];
    }
    
    /** Checks whether the circular queue is empty or not. */
    public boolean isEmpty() {
        return head == -1;
    }
    
    /** Checks whether the circular queue is full or not. */
    public boolean isFull() {
        return ((tail + 1) % size) == head;
    }
}
```

## 2.5 队列-用法

大多数流行语言都提供内置的队列库，因此您无需重新发明轮子。

如前所述，队列有两个重要的操作，**入队 `enqueue`** 和**出队 `dequeue`**。 此外，我们应该能够**获得队列中的第一个元素**，因为应该首先处理它。

下面是使用内置队列库及其常见操作的一些示例：

```java
// "static void main" must be defined in a public class.
public class Main {
    public static void main(String[] args) {
        // 1. Initialize a queue.
        Queue<Integer> q = new LinkedList();
        // 2. Get the first element - return null if queue is empty.
        System.out.println("The first element is: " + q.peek());
        // 3. Push new element.
        q.offer(5);
        q.offer(13);
        q.offer(8);
        q.offer(6);
        // 4. Pop an element.
        q.poll();
        // 5. Get the first element.
        System.out.println("The first element is: " + q.peek());
        // 7. Get the size of the queue.
        System.out.println("The size is: " + q.size());
    }
}
```

请记住，当你想要**按顺序处理元素**时，使用队列可能是一个很好的选择。



## 2.6 经典例题

### 2.6.1 数据流中的移动平均值346

**题目描述:**

给定一个整数数据流和一个窗口大小，根据该滑动窗口的大小，计算其所有整数的移动平均值。

**示例:**

```text
MovingAverage m = new MovingAverage(3);
m.next(1) = 1
m.next(10) = (1 + 10) / 2
m.next(3) = (1 + 10 + 3) / 3
m.next(5) = (10 + 3 + 5) / 3
```

**思路:**

使用`collections.deque`可以设置最大长度

```java
class MovingAverage:

    def __init__(self, size: int):
        """
        Initialize your data structure here.
        """
        from collections import deque
        self.queue = deque(maxlen=size)


    def next(self, val: int) -> float:
        self.queue.appendleft(val)
        return sum(self.queue)/ len(self.queue)
```

# 三 队列和广度优先搜索

先决条件：**树的层序遍历**

**广度优先搜索**（BFS）是一种遍历或搜索数据结构（如树或图）的算法。

如前所述，我们可以使用 BFS 在**树**中执行层序遍历。

我们也可以使用 BFS 遍历**图**。例如，我们可以使用 BFS 找到从起始结点到目标结点的路径，特别是最短路径。

我们可以在更抽象的情景中使用 BFS 遍历**所有可能的状态**。在这种情况下，我们可以把状态看作是图中的结点，而以合法的过渡路径作为图中的边。

本章节中，我们将简要介绍 BFS 是如何工作的，并着重关注队列如何帮助我们实现 BFS 算法。我们还将提供一些练习，供你自行设计和实现 BFS 算法。



## 3.1 队列和BFS

广度优先搜索（BFS）的一个常见应用是找出从根结点到目标结点的最短路径。在本文中，我们提供了一个示例来解释在 BFS 算法中是如何逐步应用队列的。

**示例**：

![jsl1](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/jsl1.gif)

**洞悉**：

观看上面的动画后，让我们回答以下问题：

1.**结点的处理顺序是什么？**

在第一轮中，我们处理根结点。在第二轮中，我们处理根结点旁边的结点；在第三轮中，我们处理距根结点两步的结点；等等等等。

与树的层序遍历类似，**越是接近根结点的结点将越早地遍历**。

如果在第 k 轮中将结点 `X` 添加到队列中，则根结点与 `X` 之间的最短路径的长度恰好是 `k`。也就是说，第一次找到目标结点时，你已经处于最短路径中。

2.**队列的入队和出队顺序是什么？**

如上面的动画所示，我们首先将根结点排入队列。然后在每一轮中，我们逐个处理已经在队列中的结点，并将所有邻居添加到队列中。值得注意的是，新添加的节点**不会**立即遍历，而是在下一轮中处理。

结点的处理顺序与它们**添加**到队列的顺序是**完全相同的顺序**，即先进先出（FIFO）。这就是我们在 BFS 中使用队列的原因。



## 3.2 广度优先搜索-模板

之前，我们已经介绍了使用 BFS 的两个主要方案：**遍历**或**找出最短路径**。通常，这发生在树或图中。正如我们在章节描述中提到的，BFS 也可以用于更抽象的场景中。

在本文中，我们将为你提供一个模板。然后，我们在本文后提供一些习题供你练习。

> 在特定问题中执行 BFS 之前确定结点和边缘非常重要。通常，结点将是实际结点或是状态，而边缘将是实际边缘或可能的转换。

### 3.2.1 模板一

**代码实现**：

```java
/**
 * Return the length of the shortest path between root and target node.
 */
int BFS(Node root, Node target) {
    Queue<Node> queue;  // store all nodes which are waiting to be processed
    int step = 0;       // number of steps neeeded from root to current node
    // initialize
    add root to queue;
    // BFS
    while (queue is not empty) {
        step = step + 1;
        // iterate the nodes which are already in the queue
        int size = queue.size();
        for (int i = 0; i < size; ++i) {
            Node cur = the first node in queue;
            return step if cur is target;
            for (Node next : the neighbors of cur) {
                add next to queue;
            }
            remove the first node from queue;
        }
    }
    return -1;          // there is no path from root to target
}
```

1. 如代码所示，在每一轮中，队列中的结点是**等待处理的结点**。
2. 在每个更外一层的 `while` 循环之后，我们**距离根结点更远一步**。变量 `step` 指示从根结点到我们正在访问的当前结点的距离。



### 3.2.2 模板二

有时，确保我们永远**不会访问一个结点两次**很重要。否则，我们可能陷入无限循环。如果是这样，我们可以在上面的代码中添加一个哈希集来解决这个问题。这是修改后的伪代码：

**代码实现**：

```java
/**
 * Return the length of the shortest path between root and target node.
 */
int BFS(Node root, Node target) {
    Queue<Node> queue;  // store all nodes which are waiting to be processed
    Set<Node> used;     // store all the used nodes
    int step = 0;       // number of steps neeeded from root to current node
    // initialize
    add root to queue;
    add root to used;
    // BFS
    while (queue is not empty) {
        step = step + 1;
        // iterate the nodes which are already in the queue
        int size = queue.size();
        for (int i = 0; i < size; ++i) {
            Node cur = the first node in queue;
            return step if cur is target;
            for (Node next : the neighbors of cur) {
                if (next is not in used) {
                    add next to queue;
                    add next to used;
                }
            }
            remove the first node from queue;
        }
    }
    return -1;          // there is no path from root to target
}
```

有两种情况你不需要使用哈希集：

1. 你完全确定没有循环，例如，在树遍历中；
2. 你确实希望多次将结点添加到队列中。



## 3.3 经典例题

### 3.3.1 岛屿数量

给你一个由 `'1'`（陆地）和 `'0'`（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

 

**示例 1：**

```
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

**示例 2：**

```
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` 的值为 `'0'` 或 `'1'`



**答案：**

```java
class Solution {
    public int numIslands(char[][] grid) {
        int M = grid.length;
        int N = grid[0].length;
        Queue<int[]> queue = new LinkedList<int[]>(); // 遍历每一座岛屿的陆地
        int[][] used =  new int[M][N]; // 判断该坐标是否被搜索过
        int index = 0; // 表示陆地序号，初始值为0

        // 遍历所有坐标
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < N; j++) {
                if (grid[i][j] == '1' && used[i][j] == 0) {
                    // 从当前坐标搜索与该点相连接的所有坐标
                    index = index + 1;
                    queue.offer(new int[]{i, j});
                    // 将该坐标点标记为访问过
                    used[i][j] = index;
                    while(!queue.isEmpty()) {
                        // 取出第一个点
                        int[] indexPoints = queue.poll();
                        int row = indexPoints[0];
                        int col = indexPoints[1];

                        // 判断该点的四个方向是否为陆地，是则加入队列，判断顺序为：上 下 左 右，注意边界
                        // 上边 row - 1
                        if (row > 0 && grid[row - 1][col] == '1' && used[row - 1][col] == 0) {
                            queue.offer(new int[]{row - 1, col});
                            used[row - 1][col] = index;
                        }
                        // 下边 row + 1
                        if (row < M - 1 && grid[row + 1][col] == '1' && used[row + 1][col] == 0) {
                            queue.offer(new int[]{row + 1, col});
                            used[row + 1][col] = index;
                        }
                        // 左边 col - 1
                        if (col > 0 && grid[row][col - 1] == '1' && used[row][col - 1] == 0) {
                            queue.offer(new int[]{row, col - 1});
                            used[row][col - 1] = index;
                        }
                        // 右边 col + 1
                        if (col < N - 1 && grid[row][col + 1] == '1' && used[row][col + 1] == 0) {
                            queue.offer(new int[]{row, col + 1});
                            used[row][col + 1] = index;
                        }
                    }
                }
            }
        }
        return index;
    }
}
```

**优化**：

```java
class Solution {
    public void dfs(char[][] grid,int row,int column){
        // 判断下标是否越界，判断是否是水和已访问的陆地
        // 注意 row 和 grid.length比较
        // colunm 和 grid[0].length 比较
        if(row<0||column<0||row>=grid.length||column>=grid[0].length||grid[row][column]=='2'||grid[row][column]=='0'){
            return;
        }
        // 此处记得修改已遍历的值
        grid[row][column] = '2';
        // 向四个方向遍历
        dfs(grid,row+1,column);
        dfs(grid,row-1,column);
        dfs(grid,row,column-1);
        dfs(grid,row,column+1);
    }

    public int numIslands(char[][] grid) {
        if(grid == null || grid.length==0){
            return 0;
        }
        int num = 0;
        for(int row=0;row<grid.length;row++){
            for(int column = 0;column<grid[0].length;column++){
                if(grid[row][column] == '1'){
                    // 遇到一个1，从该值开始遍历
                    num++;
                    dfs(grid,row,column);
                }
            }
        }
        return num;
    }
}
```



### 3.3.2 打开转盘锁752

你有一个带有四个圆形拨轮的转盘锁。每个拨轮都有10个数字： `'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'` 。每个拨轮可以自由旋转：例如把 `'9'` 变为 `'0'`，`'0'` 变为 `'9'` 。每次旋转都只能旋转一个拨轮的一位数字。

锁的初始数字为 `'0000'` ，一个代表四个拨轮的数字的字符串。

列表 `deadends` 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。

字符串 `target` 代表可以解锁的数字，你需要给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 `-1` 。

 

**示例 1:**

```
输入：deadends = ["0201","0101","0102","1212","2002"], target = "0202"
输出：6
解释：
可能的移动序列为 "0000" -> "1000" -> "1100" -> "1200" -> "1201" -> "1202" -> "0202"。
注意 "0000" -> "0001" -> "0002" -> "0102" -> "0202" 这样的序列是不能解锁的，
因为当拨动到 "0102" 时这个锁就会被锁定。
```

**示例 2:**

```
输入: deadends = ["8888"], target = "0009"
输出：1
解释：
把最后一位反向旋转一次即可 "0000" -> "0009"。
```

**示例 3:**

```
输入: deadends = ["8887","8889","8878","8898","8788","8988","7888","9888"], target = "8888"
输出：-1
解释：
无法旋转到目标数字且不被锁定。
```

**示例 4:**

```
输入: deadends = ["0000"], target = "8888"
输出：-1
```

 

**提示：**

- `1 <= deadends.length <= 500`
- `deadends[i].length == 4`
- `target.length == 4`
- `target` **不在** `deadends` 之中
- `target` 和 `deadends[i]` 仅由若干位数字组成



**答案**：

```java
class Solution {
    public int openLock(String[] deadends, String target) {
        // IF target == '0000' RETURN 0
        if ("0000".equals(target)) {
            return 0;
        }

        // ADD deadends INTO HASHMAP TO QUERY(O(1))
        Set<String> deadendsSet = new HashSet<String>();
        for (String str : deadends) {
            deadendsSet.add(str);
        }

        // IF deadens CONTAIN target RETURN -1
        if (deadendsSet.contains(target) || deadendsSet.contains("0000")) {
            return -1;
        }

        // QUEUE FOR ALL STATUS
        Queue<String> queue = new LinkedList<String>();

        // SAVE SEACHERED STATUS
        Set<String> seenSet = new HashSet<String>(); 

        // STEP
        int step = 0;

        // ADD INIT STATUS INTO QUEUE
        queue.offer("0000");
        // flag THIS STATUS
        seenSet.add("0000");

        // BFS PROCESS
        while(!queue.isEmpty()) {
            ++step;
            int size = queue.size();
            for (int i = 0; i < size; ++i) {
                String st = queue.poll();
                List<String> allStatus = getAllStatus(st);
                for (String status : allStatus) {
                    if (!deadendsSet.contains(status) && !seenSet.contains(status)) {
                        if (status.equals(target)) {
                            return step;
                        }
                        queue.offer(status);
                        seenSet.add(status);
                    }
                }
            }
        }
        return -1;
    }

    public char numPrev(char x) {
        return x == '0' ? '9' : (char)(x - 1);
    }

    public char numLast(char x) {
        return x == '9' ? '0' : (char)(x + 1);
    }

    public List<String> getAllStatus(String status) {
        char[] statusArr = status.toCharArray();
        List<String> allStatus = new ArrayList<String>();
        for (int index = 0; index < statusArr.length; index++) {
            char num = statusArr[index];
            statusArr[index] = numPrev(num);
            allStatus.add(new String(statusArr));
            statusArr[index] = numLast(num);
            allStatus.add(new String(statusArr));
            statusArr[index] = num;
        }
        return allStatus;
    }
}
```



### 3.3.3 完全平方数

给定正整数 *n*，找到若干个完全平方数（比如 `1, 4, 9, 16, ...`）使得它们的和等于 *n*。你需要让组成和的完全平方数的个数最少。

给你一个整数 `n` ，返回和为 `n` 的完全平方数的 **最少数量** 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

 

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

 

**提示：**

- `1 <= n <= 104`

**解法**：

```java
public int numSquares(int n) {
    Queue<Integer> queue = new LinkedList<>();
    //记录访问过的节点值
    Set<Integer> visited = new HashSet<>();
    queue.offer(0);
    visited.add(0);
    //树的第几层
    int level = 0;
    while (!queue.isEmpty()) {
        //每一层的节点数量
        int size = queue.size();
        level++;
        //遍历当前层的所有节点
        for (int i = 0; i < size; i++) {
            //节点的值
            int digit = queue.poll();
            //访问当前节点的子节点，类比于二叉树的左右子节点
            for (int j = 1; j <= n; j++) {
                //子节点的值
                int nodeValue = digit + j * j;
                //nodeValue始终是完全平方数的和，当他等于n的
                //时候直接返回
                if (nodeValue == n)
                    return level;
                //如果大于n，终止内层循环
                if (nodeValue > n)
                    break;
                if (!visited.contains(nodeValue)) {
                    queue.offer(nodeValue);
                    visited.add(nodeValue);
                }
            }
        }
    }
    return level;
}
```



# 三 栈：后入先出的数据结构

本章节中，我们将介绍另一种处理顺序**后入先出**（LIFO），以及相应的数据结构，**栈**。

完成本章节后，你将：

1. 理解 LIFO 和 栈的定义；
2. 能够用动态数组实现栈；
3. 熟悉内置栈结构；
4. 能够使用栈解决问题。



## 3.1 后入先出的数据结构

###                             <img src="https://aliyun-lc-upload.oss-cn-hangzhou.aliyuncs.com/aliyun-lc-upload/uploads/2018/06/03/screen-shot-2018-06-02-at-203523.png" alt="img" style="zoom:50%;" />

在 LIFO 数据结构中，将**首先处理添加到队列**中的**最新元素**。

与队列不同，栈是一个 LIFO 数据结构。通常，插入操作在栈中被称作入栈 **push** 。与队列类似，总是在**堆栈的末尾添加一个新元素**。但是，删除操作，退栈 **pop** ，将始终**删除**队列中相对于它的**最后一个元素**。

**示例—栈**：

![110](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/110.gif)

**实现-栈**：

```java
// "static void main" must be defined in a public class.
class MyStack {
    private List<Integer> data;               // store elements
    public MyStack() {
        data = new ArrayList<>();
    }
    /** Insert an element into the stack. */
    public void push(int x) {
        data.add(x);
    }
    /** Checks whether the queue is empty or not. */
    public boolean isEmpty() {
        return data.isEmpty();
    }
    /** Get the top item from the queue. */
    public int top() {
        return data.get(data.size() - 1);
    }
    /** Delete an element from the queue. Return true if the operation is successful. */
    public boolean pop() {
        if (isEmpty()) {
            return false;
        }
        data.remove(data.size() - 1);
        return true;
    }
};

public class Main {
    public static void main(String[] args) {
        MyStack s = new MyStack();
        s.push(1);
        s.push(2);
        s.push(3);
        for (int i = 0; i < 4; ++i) {
            if (!s.isEmpty()) {
                System.out.println(s.top());
            }
            System.out.println(s.pop());
        }
    }
}
```



## 3.2 栈-用法

大多数流行的语言都提供了内置的栈库，因此你不必重新发明轮子。除了**初始化**，我们还需要知道如何使用两个最重要的操作：**入栈**和**退栈**。除此之外，你应该能够从栈中**获得顶部元素**。下面是一些供你参考的代码示例：

```java
// "static void main" must be defined in a public class.
public class Main {
    public static void main(String[] args) {
        // 1. Initialize a stack.
        Stack<Integer> s = new Stack<>();
        // 2. Push new element.
        s.push(5);
        s.push(13);
        s.push(8);
        s.push(6);
        // 3. Check if stack is empty.
        if (s.empty() == true) {
            System.out.println("Stack is empty!");
            return;
        }
        // 4. Pop an element.
        s.pop();
        // 5. Get the top element.
        System.out.println("The top element is: " + s.peek());
        // 6. Get the size of the stack.
        System.out.println("The size is: " + s.size());
    }
}
```

从现在开始，我们可以使用内置的栈库来更方便地解决问题。 让我们从一个有趣的问题（**最小栈**）开始，帮助你复习有用的操作。 然后我们将看一些经典的栈问题。 当你想首先处理最后一个元素时，栈将是最合适的数据结构。



## 3.3 经典例题

### 3.3.1 最小栈155

设计一个支持 push ，pop ，top 操作，并能在常数时间内检索到最小元素的栈。

- `push(x)` —— 将元素 x 推入栈中。
- `pop()` —— 删除栈顶的元素。
- `top()` —— 获取栈顶元素。
- `getMin()` —— 检索栈中的最小元素。


示例:

```tex
输入：
["MinStack","push","push","push","getMin","pop","top","getMin"]
[[],[-2],[0],[-3],[],[],[],[]]

输出：
[null,null,null,null,-3,null,0,-2]

解释：
MinStack minStack = new MinStack();
minStack.push(-2);
minStack.push(0);
minStack.push(-3);
minStack.getMin();   --> 返回 -3.
minStack.pop();
minStack.top();      --> 返回 0.
minStack.getMin();   --> 返回 -2.
```


提示：

- `pop`、`top` 和 `getMin` 操作总是在 非空栈 上调用。

**解法**：

```java
class MinStack {
    Stack<Integer> myStack = null;
    Stack<Integer> minStack = null;

    /** initialize your data structure here. */
    public MinStack() {
        myStack = new Stack<Integer>();
        minStack = new Stack<Integer>();
    }
    
    public void push(int val) {
        myStack.push(val);
        if (minStack.empty()) {
            minStack.push(val);
        } else {
            if (val < minStack.peek()) {
                minStack.push(val);
            } else {
                minStack.push(minStack.peek());
            }
        }
    }
    
    public void pop() {
        myStack.pop();
        minStack.pop();
    }
    
    public int top() {
        return myStack.peek();
    }
    
    public int getMin() {
        return minStack.peek();
    }
}

/**
 * Your MinStack object will be instantiated and called as such:
 * MinStack obj = new MinStack();
 * obj.push(val);
 * obj.pop();
 * int param_3 = obj.top();
 * int param_4 = obj.getMin();
 */
```

### 3.3.2 有效的括号20

给定一个只包括 `'('，')'，'{'，'}'，'['，']' `的字符串 s ，判断字符串是否有效。

有效字符串需满足：

1. 左括号必须用相同类型的右括号闭合。
2. 左括号必须以正确的顺序闭合。


示例 1：

```tex
输入：s = "()"
输出：true
```

示例 2：

```tex
输入：s = "()[]{}"
输出：true
```

示例 3：

```tex
输入：s = "(]"
输出：false
```

示例 4：

```tex
输入：s = "([)]"
输出：false
```

示例 5：

```tex
输入：s = "{[]}"
输出：true
```


提示：

- `1 <= s.length <= 104`
- `s` 仅由括号 `'()[]{}'` 组成

**解法**：

```java
class Solution {
    public boolean isValid(String s) {
        Stack<Character> stack = new Stack<Character>();

        char[] sChar = s.toCharArray();

        for (char ch : sChar) {
            if (ch == '(' || ch == '{' || ch == '[') {
                stack.push(ch);
            } else {
                if (stack.empty()) {
                    return false;
                }
                if (stack.peek() == '(' && ch == ')') {
                    stack.pop();
                } else if (stack.peek() == '[' && ch == ']') {
                    stack.pop();
                } else if (stack.peek() == '{' && ch == '}') {
                    stack.pop();
                } else {
                    return false;
                }
            }
        }

        if (stack.empty()) {
            return true;
        } else {
            return false;
        }
    }
}
```

### 3.3.3 每日温度739

请根据每日 **气温** 列表 **temperatures** ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 0 来代替。

示例 1:

```tex
输入: temperatures = [73,74,75,71,69,72,76,73]
输出: [1,1,4,2,1,1,0,0]
```

示例 2:

```tex
输入: temperatures = [30,40,50,60]
输出: [1,1,1,0]
```

示例 3:

```tex
输入: temperatures = [30,60,90]
输出: [1,1,0]
```


提示：

- `1 <= temperatures.length <= 105`
- `30 <= temperatures[i] <= 100`



**解法**：

```java
class Solution {
    public int[] dailyTemperatures(int[] temperatures) {
        Stack<Integer> stack =  new Stack<Integer>();
        int[] ans = new int[temperatures.length];
        for (int i = 0; i < temperatures.length; i++) {
            int val = temperatures[i];
            while (!stack.empty() && val > temperatures[stack.peek()]) {
                int index = stack.pop();
                ans[index] = i - index;
            }
            stack.push(i);
        }
        return ans;

    }
}
```

### 3.3.4 逆波兰表达式求值150

根据 逆波兰表示法，求表达式的值。

有效的算符包括 +、-、*、/ 。每个运算对象可以是整数，也可以是另一个逆波兰表达式。

 

说明：

- 整数除法只保留整数部分。
- 给定逆波兰表达式总是有效的。换句话说，表达式总会得出有效数值且不存在除数为 0 的情况。


示例 1：

```tex
输入：tokens = ["2","1","+","3","*"]
输出：9
解释：该算式转化为常见的中缀算术表达式为：((2 + 1) * 3) = 9
```

示例 2：

```tex
输入：tokens = ["4","13","5","/","+"]
输出：6
解释：该算式转化为常见的中缀算术表达式为：(4 + (13 / 5)) = 6
```

示例 3：

```tex
输入：tokens = ["10","6","9","3","+","-11","*","/","*","17","+","5","+"]
输出：22
解释：
该算式转化为常见的中缀算术表达式为：
  ((10 * (6 / ((9 + 3) * -11))) + 17) + 5
= ((10 * (6 / (12 * -11))) + 17) + 5
= ((10 * (6 / -132)) + 17) + 5
= ((10 * 0) + 17) + 5
= (0 + 17) + 5
= 17 + 5
= 22
```


提示：

- `1 <= tokens.length <= 104`
- `tokens[i]` 要么是一个算符（`"+"`、`"-"`、`"*"` 或 `"/"`），要么是一个在范围 `[-200, 200]` 内的整数


逆波兰表达式：

逆波兰表达式是一种后缀表达式，所谓后缀就是指算符写在后面。

- 平常使用的算式则是一种中缀表达式，如 ( 1 + 2 ) * ( 3 + 4 ) 。

- 该算式的逆波兰表达式写法为 ( ( 1 2 + ) ( 3 4 + ) * ) 。

逆波兰表达式主要有以下两个优点：

- 去掉括号后表达式无歧义，上式即便写成 1 2 + 3 4 + * 也可以依据次序计算出正确结果。
- 适合用栈操作运算：遇到数字则入栈；遇到算符则取出栈顶两个数字进行计算，并将结果压入栈中。



**解法**：

```java
class Solution {
    public int evalRPN(String[] tokens) {
        Stack<String> numStack = new Stack<String>();
        for (int i = 0; i < tokens.length; i++) {
            if (tokens[i].equals("+")) {
                int b = Integer.parseInt(numStack.pop());
                int a = Integer.parseInt(numStack.pop());
                int result = a + b;
                numStack.push(Integer.toString(result));
            } else if (tokens[i].equals("-")) {
                int b = Integer.parseInt(numStack.pop());
                int a = Integer.parseInt(numStack.pop());
                int result = a - b; 
                numStack.push(Integer.toString(result));
            } else if (tokens[i].equals("*")) {
                int b = Integer.parseInt(numStack.pop());
                int a = Integer.parseInt(numStack.pop());
                int result = a * b; 
                numStack.push(Integer.toString(result));
            } else if (tokens[i].equals("/")) {
                int b = Integer.parseInt(numStack.pop());
                int a = Integer.parseInt(numStack.pop());
                int result = a / b; 
                numStack.push(Integer.toString(result));
            } else {
                numStack.push(tokens[i]);
            }
        }
        return Integer.parseInt(numStack.pop());
    }
}
```



# 四 栈和深度优先搜索

先决条件：树的遍历

与 BFS 类似，**深度优先搜索**（DFS）是用于 在**树/图中遍历/搜索** 的另一种重要算法。也可以在更抽象的场景中使用。

正如树的遍历中所提到的，我们可以用 DFS 进行 **前序遍历**，**中序遍历** 和 **后序遍历**。在这三个遍历顺序中有一个共同的特性：**除非我们到达最深的结点，否则我们永远不会回溯** 。

这也是 DFS 和 BFS 之间最大的区别，**BFS永远不会深入探索，除非它已经在当前层级访问了所有结点**。

通常，我们使用递归实现 DFS。栈在递归中起着重要的作用。在本章中，我们将解释在执行递归时栈的作用。我们还将向你展示递归的缺点，并提供另一个 **没有递归** 的 DFS 实现。

在准备面试时，DFS 是一个重要的话题。DFS 的实际设计因题而异。本章重点介绍栈是如何在 DFS 中应用的，并帮助你更好地理解 DFS 的原理。要精通 DFS 算法，还需要大量的练习。



## 4.1 栈和DFS

与 BFS 类似，**深度优先搜索**（DFS）也可用于查找从根结点到目标结点的路径。在本文中，我们提供了示例来解释 DFS 是如何工作的以及栈是如何逐步帮助 DFS 工作的。

**示例**

我们来看一个例子吧。我们希望通过 DFS 找出从根结点 `A` 到目标结点 `G` 的路径。

![111](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/111.gif)

**洞悉**

观看上面的动画后，让我们回答以下问题：

1.**结点的处理顺序是什么？**

在上面的例子中，我们从根结点 `A` 开始。首先，我们选择结点 `B` 的路径，并进行回溯，直到我们到达结点 `E`，我们无法更进一步深入。然后我们回溯到 `A` 并选择第二条路径到结点 `C` 。从 `C` 开始，我们尝试第一条路径到 `E` 但是 `E` 已被访问过。所以我们回到 `C` 并尝试从另一条路径到 `F`。最后，我们找到了 `G`。

总的来说，在我们到达**最深的**结点之后，我们**只**会回溯并尝试另一条路径。

> 因此，你在 DFS 中找到的第一条路径并不总是最短的路径。例如，在上面的例子中，我们成功找出了路径 `A-> C-> F-> G` 并停止了 DFS。但这不是从 `A` 到 `G` 的最短路径。

2.**栈的入栈和退栈顺序是什么？**

如上面的动画所示，我们首先将根结点推入到栈中；然后我们尝试第一个邻居 `B` 并将结点 `B` 推入到栈中；等等等等。当我们到达最深的结点 `E` 时，我们需要回溯。当我们回溯时，我们将从栈中**弹出最深的**结点，这实际上是推入到栈中的**最后一个结点**。

结点的处理顺序是**完全相反的顺序**，就像它们被**添加**到栈中一样，它是后进先出（LIFO）。这就是我们在 DFS 中使用栈的原因。



## 4.2 DFS-模板1

正如我们在本章的描述中提到的，在大多数情况下，我们在能使用 BFS 时也可以使用 DFS。但是有一个重要的区别：**遍历顺序**。

与 BFS 不同，**更早访问的结点可能不是更靠近根结点的结点**。因此，你在 DFS 中找到的第一条路径**可能不是最短路径**。

在本文中，我们将为你提供一个 DFS 的递归模板，并向你展示栈是如何帮助这个过程的。在这篇文章之后，我们会提供一些练习给大家练习。

**模板-递归**：

有两种实现 DFS 的方法。第一种方法是进行递归，这一点你可能已经很熟悉了。这里我们提供了一个模板作为参考：

```java
/*
 * Return true if there is a path from cur to target.
 */
boolean DFS(Node cur, Node target, Set<Node> visited) {
    return true if cur is target;
    for (next : each neighbor of cur) {
        if (next is not in visited) {
            add next to visted;
            return true if DFS(next, target, visited) == true;
        }
    }
    return false;
}
```

当我们递归地实现 DFS 时，似乎不需要使用任何栈。但实际上，我们使用的是由系统提供的隐式栈，也称为调用栈（[Call Stack](https://en.wikipedia.org/wiki/Call_stack)）。

**示例**：

让我们看一个例子。我们希望在下图中找到结点 0 和结点 3 之间的路径。我们还会在每次调用期间显示栈的状态。

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210913161948900.png" alt="image-20210913161948900" style="zoom: 25%;" />

在每个堆栈元素中，都有一个整数 `cur`，一个整数 `target`，一个对**访问过**的数组的引用和一个对数组**边界**的引用，这些正是我们在 DFS 函数中的参数。我们只在上面的栈中显示 `cur`。

每个元素都需要固定的空间。**栈的大小正好是 DFS 的深度**。因此，在最坏的情况下，维护系统栈需要 O(h)，其中 h 是 DFS 的最大深度。在计算空间复杂度时，永远不要忘记考虑系统栈。

> 在上面的模板中，我们在找到`第一条`路径时停止。
>
> 如果你想找到`最短`路径呢？
>
> 提示：再添加一个参数来指示你已经找到的最短路径。



## 4.3 经典例题

### 4.3.1 岛屿数量200

给你一个由 '1'（陆地）和 '0'（水）组成的的二维网格，请你计算网格中岛屿的数量。

岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。

此外，你可以假设该网格的四条边均被水包围。

示例 1：

```tex
输入：grid = [
  ["1","1","1","1","0"],
  ["1","1","0","1","0"],
  ["1","1","0","0","0"],
  ["0","0","0","0","0"]
]
输出：1
```

示例 2：

```tex
输入：grid = [
  ["1","1","0","0","0"],
  ["1","1","0","0","0"],
  ["0","0","1","0","0"],
  ["0","0","0","1","1"]
]
输出：3
```


提示：

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 300`
- `grid[i][j]` 的值为 `'0'` 或 `'1'`



**解法**：

```java
class Solution {
    public int numIslands(char[][] grid) {
        int m = grid.length;
        int n = grid[0].length;
        int[][] visited = new int[m][n];

        Stack<int[]> stack = new Stack<int[]>();

        int index = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (grid[i][j] == '1' && visited[i][j] == 0) {
                    stack.push(new int[]{i, j});
                    index++;
                }
              
                while (!stack.empty()) {
                    int[] ponit = stack.pop();
                    int row = ponit[0];
                    int col = ponit[1];

                    // 访问该点
                    visited[row][col] = index;

                    // 判断上边 (row - 1, col)
                    if (row - 1 >= 0 && grid[row - 1][col] == '1' && visited[row - 1][col] == 0) {
                        stack.push(new int[]{row - 1, col});
                    }

                    // 判断下边 (row + 1, col)
                    if (row + 1 <= m - 1 && grid[row + 1][col] == '1' && visited[row + 1][col] == 0) {
                        stack.push(new int[]{row + 1, col});
                    }

                    // 判断左边 (row, col - 1)
                    if (col - 1 >= 0 && grid[row][col - 1] == '1' && visited[row][col - 1] == 0) {
                        stack.push(new int[]{row, col - 1});
                    }

                    // 判断右边 (row, col + 1)
                    if (col + 1 <= n - 1 && grid[row][col + 1] == '1' && visited[row][col + 1] == 0) {
                        stack.push(new int[]{row, col + 1});
                    }           
                }
            }
        }

        return index;
    }
}
```

### 4.3.2 克隆图133

给你无向 连通 图中一个节点的引用，请你返回该图的 深拷贝（克隆）。

图中的每个节点都包含它的值 val（int） 和其邻居的列表（list[Node]）。

```java
class Node {
    public int val;
    public List<Node> neighbors;
}
```

**测试用例格式：**

简单起见，每个节点的值都和它的索引相同。例如，第一个节点值为 1（val = 1），第二个节点值为 2（val = 2），以此类推。该图在测试用例中使用邻接列表表示。

邻接列表 是用于表示有限图的无序列表的集合。每个列表都描述了图中节点的邻居集。

给定节点将始终是图中的第一个节点（值为 1）。你必须将 **给定节点的拷贝** 作为对克隆图的引用返回。

 

**示例 1：**

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210914113608851.png" alt="image-20210914113608851" style="zoom: 33%;" />

```tex
输入：adjList = [[2,4],[1,3],[2,4],[1,3]]
输出：[[2,4],[1,3],[2,4],[1,3]]
解释：
图中有 4 个节点。
节点 1 的值是 1，它有两个邻居：节点 2 和 4 。
节点 2 的值是 2，它有两个邻居：节点 1 和 3 。
节点 3 的值是 3，它有两个邻居：节点 2 和 4 。
节点 4 的值是 4，它有两个邻居：节点 1 和 3 。
```

示例 2：

![image-20210914113648039](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210914113648039.png)

```tex
输入：adjList = [[]]
输出：[[]]
解释：输入包含一个空列表。该图仅仅只有一个值为 1 的节点，它没有任何邻居。
```

示例 3：

```tex
输入：adjList = []
输出：[]
解释：这个图是空的，它不含任何节点。
```

示例 4：

![image-20210914113719992](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210914113719992.png)

```tex
输入：adjList = [[2],[1]]
输出：[[2],[1]]
```

**提示：**

- 节点数不超过 100 。
- 每个节点值 Node.val 都是唯一的，1 <= Node.val <= 100。
- 无向图是一个简单图，这意味着图中没有重复的边，也没有自环。
- 由于图是无向的，如果节点 p 是节点 q 的邻居，那么节点 q 也必须是节点 p 的邻居。
- 图是连通图，你可以从给定节点访问到所有节点。



**解法**：

```java
// 深度优先搜索 DFS
class Solution {
    Map<Node, Node> visitedNode = new HashMap<Node, Node> ();
    public Node cloneGraph(Node node) {
        if (node == null) {
            return null;
        }

        if (visitedNode.containsKey(node)) {
            return visitedNode.get(node);
        }

        Node cloneNode = new Node(node.val, new ArrayList());
        visitedNode.put(node, cloneNode);

        for (Node neighborNode : node.neighbors) {
            cloneNode.neighbors.add(cloneGraph(neighborNode));
        }

        return cloneNode;
    }
}
```

```java
// 广度搜索 BFS
class Solution {
    public static Map<Node, Node> visitedNode = new HashMap<Node, Node> ();
    public Node cloneGraph(Node node) {
        if (node == null) {
            return null;
        }

        // 1.先遍历原图，创建原始图所有对应的节点
        Queue<Node> q = new LinkedList<Node> ();
        q.offer(node);
        while (!q.isEmpty()) {
            Node curNode = q.poll();

            Node cloneNode = new Node(curNode.val, new ArrayList<Node>());

            visitedNode.put(curNode, cloneNode);

            for (Node neighbor : curNode.neighbors) {
                if (!visitedNode.containsKey(neighbor)) {
                    q.offer(neighbor);
                }
            }
        }

        // 2.遍历vistedNode，依次添加连接关系
        for (Map.Entry<Node, Node> entry : visitedNode.entrySet()) {
            Node key = entry.getKey();
            Node val = entry.getValue();
            for (Node neighbor : key.neighbors) {
                val.neighbors.add(visitedNode.get(neighbor));
            }
        }

        return visitedNode.get(node);
    }
}
```

### 4.3.3 目标和494

给你一个整数数组 `nums` 和一个整数 `target` 。

向数组中的每个整数前添加 `'+'` 或 `'-'` ，然后串联起所有整数，可以构造一个 **表达式** ：

- 例如，`nums = [2, 1]` ，可以在 `2` 之前添加 `'+'` ，在 `1` 之前添加 `'-'` ，然后串联起来得到表达式 `"+2-1"` 。

返回可以通过上述方法构造的、运算结果等于 `target` 的不同 **表达式** 的数目。

 

示例 1：

```tex
输入：nums = [1,1,1,1,1], target = 3
输出：5
解释：一共有 5 种方法让最终目标和为 3 。
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3
```

示例 2：

```tex
输入：nums = [1], target = 1
输出：1
```


提示：

- `1 <= nums.length <= 20`
- `0 <= nums[i] <= 1000`
- `0 <= sum(nums[i]) <= 1000`
- `-1000 <= target <= 1000`



**解法**：

```java
// DFS 递归实现
class Solution {
    int[] ans = new int[1];
    public int findTargetSumWays(int[] nums, int target) {
        findTargetSum(nums, target, 0, 0, '+');
        findTargetSum(nums, target, 0, 0, '-');
        return ans[0] / 2;
    }

    public void findTargetSum(int[] nums, int target, int prev, int index, char ch) {
        if (index < nums.length) {
            if (ch == '+') {
                findTargetSum(nums, target, prev + nums[index], index + 1, '+');
                findTargetSum(nums, target, prev + nums[index], index + 1, '-');
            } else {
                findTargetSum(nums, target, prev - nums[index], index + 1, '+');
                findTargetSum(nums, target, prev - nums[index], index + 1, '-');
            }
        } else {
            if (prev == target) {
                ans[0] = ans[0] + 1;
            }
        }
    }
}
```

### 4.3.4 二叉树的中序遍历94

给定一个二叉树的根节点 `root` ，返回它的 **中序** 遍历。

 **解法**：

```java
// 递归版
class Solution {
    List<Integer> list = new ArrayList<Integer> ();

    public List<Integer> inorderTraversal(TreeNode root) {
        if (root == null) {
            return list;
        }

        if (root.left != null) {
            inorderTraversal(root.left);
        }

        list.add(root.val);

        if (root.right != null) {
            inorderTraversal(root.right);
        }

        return list;
    }
}
```

```java
// 栈实现非递归
class Solution {
    public List<Integer> inorderTraversal(TreeNode root) {
        List<Integer> list = new ArrayList<Integer> ();
        Stack<TreeNode> s = new Stack<TreeNode> ();

        if (root == null) {
            return list;
        }

        s.push(root);
        while(s.peek() != null) {
            // 从该节点出发，左孩子一直入栈，直到null
            TreeNode curNode = s.peek();
            while (curNode.left != null) {
                curNode = curNode.left;
                s.push(curNode);
            }
            // 无左孩子可入栈，则弹出栈顶访问
            TreeNode vistedNode = s.pop();
            list.add(vistedNode.val);

            while (vistedNode.right == null && !s.empty()) {
                vistedNode = s.pop();
                list.add(vistedNode.val);
            }
            s.push(vistedNode.right);
        }

        return list;
    }
}
```



## 4.4 DFS-模板2

递归解决方案的优点是它更容易实现。 但是，存在一个很大的缺点：如果递归的深度太高，你将遭受堆栈溢出。 在这种情况下，您可能会希望使用 BFS，或使用显式栈实现 DFS。

```java
/*
 * Return true if there is a path from cur to target.
 */
boolean DFS(int root, int target) {
    Set<Node> visited;
    Stack<Node> s;
    add root to s;
    while (s is not empty) {
        Node cur = the top element in s;
        return true if cur is target;
        for (Node next : the neighbors of cur) {
            if (next is not in visited) {
                add next to s;
                add next to visited;
            }
        }
        remove cur from s;
    }
    return false;
}
```



# 五 小结

在前面的章节中，我们介绍了两个数据结构：**队列和栈**

**1.队列**

**队列**是一种 **FIFO** 式的数据结构：第一个元素将被首先处理。有两个重要操作：**入队和出队**。我们可以使用带有两个指针的动态数组来实现队列。

我们可以使用**广度优先搜索（BFS）**。

队列还有一些重要的扩展，例如：

- 双端队列
  优先队列

我们在后面的卡片中介绍这些结构。

**2.栈**

**栈**是一种 **LIFO** 式的数据结构：最后一个元素将被首先处理。有两个重要操作：**push 和 pop**。栈的实现非常简单，使用动态数组就足以实现栈。

当满足 LIFO 原则时，我们使用栈。**深度优先搜索（DFS）**是栈的一个重要应用。

**3.总结**

总之，你应该能够理解和比较以下几组概念：

- FIFO 和 LIFO；
- 队列 和 栈；
- BFS 和 DFS；

要熟练掌握这个主题，最好的办法就是训练。本章节中，我们为你提供了更多练习。



## 5.1 用栈实现队列232

请你仅使用两个栈实现先入先出队列。队列应当支持一般队列支持的所有操作（push、pop、peek、empty）：

实现 `MyQueue` 类：

- `void push(int x)` 将元素 x 推到队列的末尾
- `int pop()` 从队列的开头移除并返回元素
- `int peek()` 返回队列开头的元素
- `boolean empty()` 如果队列为空，返回 `true` ；否则，返回 `false`


说明：

- 你只能使用标准的栈操作 —— 也就是只有 `push to top`, `peek/pop from top`, `size`, 和 `is empty` 操作是合法的。
- 你所使用的语言也许不支持栈。你可以使用 `list` 或者 `deque`（双端队列）来模拟一个栈，只要是标准的栈操作即可。


进阶：

- 你能否实现每个操作均摊时间复杂度为 `O(1)` 的队列？换句话说，执行 `n` 个操作的总时间复杂度为 `O(n)` ，即使其中一个操作可能花费较长时间。


示例：

```tex
输入：
["MyQueue", "push", "push", "peek", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 1, 1, false]

解释：
MyQueue myQueue = new MyQueue();
myQueue.push(1); // queue is: [1]
myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue)
myQueue.peek(); // return 1
myQueue.pop(); // return 1, queue is [2]
myQueue.empty(); // return false
```


提示：

- `1 <= x <= 9`
- 最多调用 `100` 次 `push`、`pop`、`peek` 和 `empty`
- 假设所有操作都是有效的 （例如，一个空的队列不会调用 `pop` 或者 `peek` 操作）



**解法**：

```java
class MyQueue {
    Stack<Integer> stack1 = null;
    Stack<Integer> stack2 = null;
    int front;

    /** Initialize your data structure here. */
    public MyQueue() {
        stack1 = new Stack<Integer> ();
        stack2 = new Stack<Integer> ();
    }
    
    /** Push element x to the back of queue. */
    public void push(int x) {
        if (stack1.empty()) {
            front = x;
        }
        stack1.push(x);
    }
    
    /** Removes the element from in front of queue and returns that element. */
    public int pop() {
        if (stack2.empty()) {
            while(!stack1.empty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.pop();
    }
    
    /** Get the front element. */
    public int peek() {
        if (stack2.empty()) {
            while(!stack1.empty()) {
                stack2.push(stack1.pop());
            }
        }
        return stack2.peek();
    }
    
    /** Returns whether the queue is empty. */
    public boolean empty() {
        return stack1.empty() && stack2.empty();
    }
}

/**
 * Your MyQueue object will be instantiated and called as such:
 * MyQueue obj = new MyQueue();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.peek();
 * boolean param_4 = obj.empty();
 */
```

## 5.2 用队列实现栈225

请你仅使用两个队列实现一个后入先出（LIFO）的栈，并支持普通栈的全部四种操作（`push`、`top`、`pop` 和 `empty`）。

实现 `MyStack` 类：

- `void push(int x)` 将元素 x 压入栈顶。
- `int pop()` 移除并返回栈顶元素。
- `int top()` 返回栈顶元素。
- `boolean empty()` 如果栈是空的，返回 `true` ；否则，返回 `false` 。


注意：

- 你只能使用队列的基本操作 —— 也就是 push to back、peek/pop from front、size 和 is empty 这些操作。
- 你所使用的语言也许不支持队列。 你可以使用 list （列表）或者 deque（双端队列）来模拟一个队列 , 只要是标准的队列操作即可。


示例：

```tex
输入：
["MyStack", "push", "push", "top", "pop", "empty"]
[[], [1], [2], [], [], []]
输出：
[null, null, null, 2, 2, false]

解释：
MyStack myStack = new MyStack();
myStack.push(1);
myStack.push(2);
myStack.top(); // 返回 2
myStack.pop(); // 返回 2
myStack.empty(); // 返回 False
```


提示：

- `1 <= x <= 9`
- 最多调用`100` 次 `push`、`pop`、`top` 和 `empty`
- 每次调用 `pop` 和 `top` 都保证栈不为空

进阶：你能否实现每种操作的均摊时间复杂度为 `O(1)` 的栈？换句话说，执行 `n` 个操作的总时间复杂度 `O(n)` ，尽管其中某个操作可能需要比其他操作更长的时间。你可以使用两个以上的队列。



**解法**：

```java
class MyStack {

    Queue<Integer> q1 = null;
    Queue<Integer> q2 = null;

    /** Initialize your data structure here. */
    public MyStack() {
        q1 = new LinkedList<Integer> ();
        q2 = new LinkedList<Integer> ();
    }
    
    /** Push element x onto stack. */
    public void push(int x) {
        if (q1.isEmpty() && q2.isEmpty()) {
            q1.offer(x);
        } else {
            if (q1.isEmpty()) {
                q2.offer(x);
            } else {
                q1.offer(x);
            }
        }
    }
    
    /** Removes the element on top of the stack and returns that element. */
    public int pop() {
        if (q1.isEmpty()) {
            while(q2.size() != 1) {
                q1.offer(q2.poll());
            }
            return q2.poll();
        }

        if (q2.isEmpty()) {
            while (q1.size() != 1) {
                q2.offer(q1.poll());
            }
            return q1.poll();
        }
        return -1;
    }
    
    /** Get the top element. */
    public int top() {
        if (q1.isEmpty()) {
            while(q2.size() != 1) {
                q1.offer(q2.poll());
            }
            int ans = q2.peek();
            q1.offer(q2.poll());
            return ans;
        }

        if (q2.isEmpty()) {
            while (q1.size() != 1) {
                q2.offer(q1.poll());
            }
            int ans = q1.peek();
            q2.offer(q1.poll());
            return ans;
        }
        return -1;
    }
    
    /** Returns whether the stack is empty. */
    public boolean empty() {
        return q1.isEmpty() && q2.isEmpty();
    }
}

/**
 * Your MyStack object will be instantiated and called as such:
 * MyStack obj = new MyStack();
 * obj.push(x);
 * int param_2 = obj.pop();
 * int param_3 = obj.top();
 * boolean param_4 = obj.empty();
 */
```



## 5.3 字符串解码394

给定一个经过编码的字符串，返回它解码后的字符串。

编码规则为: `k[encoded_string]`，表示其中方括号内部的 *encoded_string* 正好重复 k 次。注意 k 保证为正整数。

你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。

此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 k ，例如不会出现像 `3a` 或 `2[4]` 的输入。

 

示例 1：

```tex
输入：s = "3[a]2[bc]"
输出："aaabcbc"
```

示例 2：

```tex
输入：s = "3[a2[c]]"
输出："accaccacc"
```

示例 3：

```tex
输入：s = "2[abc]3[cd]ef"
输出："abcabccdcdcdef"
```

示例 4：

```tex
输入：s = "abc3[cd]xyz"
输出："abccdcdcdxyz"
```

**解法**：

```java
class Solution {
    public String decodeString(String s) {
        Stack<Integer> s1 = new Stack<> ();
        Stack<Character> s2 = new Stack<> ();
        Stack<Character> s3 = new Stack<> ();

        char[] Arr = s.toCharArray();

        for (int i = 0; i < Arr.length; i++) {

            // 如果为 数字 ，则入栈 s1
            if (Arr[i] >= '0' && Arr[i] <= '9') {
                // 如果当前位置为 数字 0-9，则判断后续是否还有数组
                int j = i;
                for (; j < Arr.length; j++) {
                    if (Arr[j] >= '0' && Arr[j] <= '9') {
                        continue;
                    } else {
                        break;
                    }
                }
                // 找到 从下标 i 到 j 的所有数字，组成一个完整的正整数，入栈 s1
                int sum = 0;
                for (int k = i; k < j; k++) {
                    sum = sum * 10 + Integer.parseInt(String.valueOf(Arr[k]));
                }

                s1.push(sum);
                i = j -1;
            }

            // 如果为 [ 或者 a - z， 则入栈 s2
            if (Arr[i] == '[' || (Arr[i] >= 'a' && Arr[i] <= 'z')) {
                s2.push(Arr[i]);
            }

            // 如果为 ] , 则 从 s2 出栈到 [ 为止， 然后从 s1 中 取值栈顶数字， 扩大该 子串，然后入栈
            if (Arr[i] == ']') {
                Stack<Character> tempS = new Stack<Character> ();
                while (s2.peek() != '[') {
                    tempS.push(s2.pop());
                }
                s2.pop(); // 保证将对应的 [ 出栈(s2最后应该保存的为有效输出，不应该有'[]')

                // 逆转顺序
                char[] tempC = new char[tempS.size()];
                int j = 0;
                while(!tempS.empty()) {
                    tempC[j++] = tempS.pop();
                }

                // 从 s1 中去除栈顶的有效正整数k，将 tempC 中的子串复制k遍
                int k = s1.pop();
                int len = tempC.length;
                while (k-- > 0) {
                    for (j = 0; j < len; j++) {
                        s2.push(tempC[j]);
                    }
                }
            }
        }

        // 将 s2 中的 字符 拼接成 完整的 String, 并返回
        StringBuilder ans = new StringBuilder();

        while (!s2.empty()) {
            s3.push(s2.pop());
        }

        while (!s3.empty()) {
            ans.append(String.valueOf(s3.pop()));
        }

        return ans.toString();
    }
}
```



## 5.4 图像渲染733

有一幅以二维整数数组表示的图画，每一个整数表示该图画的像素值大小，数值在 0 到 65535 之间。

给你一个坐标  `(sr, sc)` 表示图像渲染开始的像素值（行 ，列）和一个新的颜色值 `newColor`，让你重新上色这幅图像。

为了完成上色工作，从初始坐标开始，记录初始坐标的上下左右四个方向上像素值与初始坐标相同的相连像素点，接着再记录这四个方向上符合条件的像素点与他们对应四个方向上像素值与初始坐标相同的相连像素点，……，重复该过程。将所有有记录的像素点的颜色值改为新的颜色值。

最后返回经过上色渲染后的图像。

示例 1:

```tex
输入: 
image = [[1,1,1],[1,1,0],[1,0,1]]
sr = 1, sc = 1, newColor = 2
输出: [[2,2,2],[2,2,0],[2,0,1]]
解析: 
在图像的正中间，(坐标(sr,sc)=(1,1)),
在路径上所有符合条件的像素点的颜色都被更改成2。
注意，右下角的像素没有更改为2，
因为它不是在上下左右四个方向上与初始点相连的像素点。
```

注意:

- `image` 和 `image[0]` 的长度在范围 `[1, 50]` 内。
- 给出的初始点将满足 `0 <= sr < image.length` 和 `0 <= sc < image[0].length`。
- `image[i][j]` 和 `newColor` 表示的颜色值在范围 `[0, 65535]`内。

**解法**：

```java
class Solution {
    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {
        int M = image.length; // 图像高
        int N = image[0].length; // 图像宽

        int[][] visited = new int[M][N]; // 标记数组
        Queue<int[]> queue = new LinkedList<int[]> ();

        // 初始化，初始坐标入队
        queue.offer(new int[]{sr, sc});
        // 开始BFS
        while(!queue.isEmpty()) {
            // 出队栈顶元素
            int[] point = queue.poll();
            int row = point[0]; // 行坐标
            int col = point[1]; // 纵坐标

            // 修改该点像素值，并做标记
            int oldColor = image[row][col];
            image[row][col] = newColor;
            visited[row][col] = 1;

            // 上边 row - 1, col
            int tempRow = row >= 1 ? row - 1 : 0;
            if (image[tempRow][col] == oldColor && visited[tempRow][col] == 0) {
                queue.offer(new int[]{tempRow, col});
            }

            // 下边 row + 1, col
            tempRow = row < M - 1 ? row + 1 : M - 1;
            if (image[tempRow][col] == oldColor && visited[tempRow][col] == 0) {
                queue.offer(new int[]{tempRow, col});
            }

            // 左边 row, col - 1
            int tempCol = col >= 1 ? col - 1 : 0;
            if (image[row][tempCol] == oldColor && visited[row][tempCol] == 0) {
                queue.offer(new int[]{row, tempCol});
            }

            // 右边 row, col + 1
            tempCol = col < N - 1 ? col + 1 : N - 1;
            if (image[row][tempCol] == oldColor && visited[row][tempCol] == 0) {
                queue.offer(new int[]{row, tempCol});
            }

        }
        return image;
    }
}
```

## 5.5 01矩阵542

给定一个由 `0` 和 `1` 组成的矩阵 `mat` ，请输出一个大小相同的矩阵，其中每一个格子是 `mat` 中对应位置元素到最近的 `0` 的距离。

两个相邻元素间的距离为 `1` 。

 

示例 1：

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210915212727073.png" alt="image-20210915212727073" style="zoom:67%;" />

```tex
输入：mat = [[0,0,0],[0,1,0],[0,0,0]]
输出：[[0,0,0],[0,1,0],[0,0,0]]
```


示例 2：

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210915212759819.png" alt="image-20210915212759819" style="zoom:67%;" />

```tex
输入：mat = [[0,0,0],[0,1,0],[1,1,1]]
输出：[[0,0,0],[0,1,0],[1,2,1]]
```


提示：

- `m == mat.length`
- `n == mat[i].length`
- `1 <= m, n <= 104`
- `1 <= m * n <= 104`
- `mat[i][j] is either 0 or 1.`
- `mat` 中至少有一个 `0` 



**解法**：

```java
// 此方法会超时
class Solution {
    /*
        思路：
        从每一个左边点开始BFS，类似层序遍历，从当前坐标点到有0的层数即为距离
    */
    public int[][] updateMatrix(int[][] mat) {
        int M = mat.length;
        int N = mat[0].length;
        int[][] dist = new int[M][N];
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < N; j++) {
                if (mat[i][j] == 0) {
                    dist[i][j] = 0;
                } else {
                    dist[i][j] = BFS(mat, i, j);
                }
            }
        }
        return dist;
    }

    public int BFS(int[][]mat, int a, int b) {
        int M = mat.length;
        int N = mat[0].length;
        int[][] visited = new int[M][N];
        Queue<int[]> queue = new LinkedList<int[]> ();

        int index = 0;

        queue.offer(new int[]{a, b});

        while(!queue.isEmpty()) {
            int queueSize = queue.size();
            for (int i = 0; i < queueSize; i++) {
                int[] point = queue.poll();
                int row = point[0];
                int col = point[1];
                visited[row][col] = 1;

                if (mat[row][col] == 0) {
                    return index;
                }

                // 上边 row - 1, col
                int tempRow = row >= 1 ? row - 1 : 0;
                if (visited[tempRow][col] == 0) {
                    queue.offer(new int[]{tempRow, col});
                }

                // 下边 row + 1, col
                tempRow = row < M - 1 ? row + 1 : M - 1;
                if (visited[tempRow][col] == 0) {
                    queue.offer(new int[]{tempRow, col});
                }

                // 左边 row, col - 1
                int tempCol = col >= 1 ? col - 1 : 0;
                if (visited[row][tempCol] == 0) {
                    queue.offer(new int[]{row, tempCol});
                }

                // 右边 row, col + 1
                tempCol = col < N - 1 ? col + 1 : N - 1;
                if (visited[row][tempCol] == 0) {
                    queue.offer(new int[]{row, tempCol});
                }

            }
            index++;
        }
        return index;
    }
}
```

```java
class Solution {
    /*
        思路：
        从每一个左边点开始BFS，类似层序遍历，从当前坐标点到有0的层数即为距离
    */
    public int[][] updateMatrix(int[][] mat) {
        int M = mat.length;
        int N = mat[0].length;
        int[][] dist = new int[M][N];
        int[][] visited = new int[M][N];
        Queue<int[]> queue = new LinkedList<int[]> ();

        // 初始化，将 mat 中所有为 0 的坐标点 入队， 修改 dist 和 visited
        for (int i = 0; i < M; i++) {
            for (int j = 0; j < N; j++) {
                if (mat[i][j] == 0) {
                    queue.offer(new int[]{i, j});
                    visited[i][j] = 1;
                }
            }
        }
        
        int distance = 0;

        // BFS 遍历 mat
        while (!queue.isEmpty()) {
            int queueSize = queue.size();
            for (int i = 0; i < queueSize; i++) {
                int[] point = queue.poll();
                int row = point[0];
                int col = point[1];

                dist[row][col] = distance;

                int tempRow;
                int tempCol;

                // 上边 row - 1, col
                tempRow = row >= 1 ? row - 1 : 0;
                if (visited[tempRow][col] == 0) {
                    queue.offer(new int[]{tempRow, col});
                    visited[tempRow][col] = 1;
                }

                // 下边 row + 1, col
                tempRow = row < M - 1 ? row + 1 : M - 1;
                if (visited[tempRow][col] == 0) {
                    queue.offer(new int[]{tempRow, col});
                    visited[tempRow][col] = 1;
                }

                // 左边 row, col - 1
                tempCol = col >= 1 ? col - 1 : 0;
                if (visited[row][tempCol] == 0) {
                    queue.offer(new int[]{row, tempCol});
                    visited[row][tempCol] = 1;
                }

                // 右边 row, col + 1
                tempCol = col < N - 1 ? col + 1 : N - 1;
                if (visited[row][tempCol] == 0) {
                    queue.offer(new int[]{row, tempCol});
                    visited[row][tempCol] = 1;
                }
            }
            distance++;
        }

        return dist;
    }
}
```



## 5.6 钥匙和房间841

有 `N` 个房间，开始时你位于 `0` 号房间。每个房间有不同的号码：`0，1，2，...，N-1`，并且房间里可能有一些钥匙能使你进入下一个房间。

在形式上，对于每个房间 i 都有一个钥匙列表 `rooms[i]`，每个钥匙 `rooms[i][j]` 由 `[0,1，...，N-1]` 中的一个整数表示，其中 `N = rooms.length`。 钥匙 `rooms[i][j] = v` 可以打开编号为 `v` 的房间。

最初，除 `0` 号房间外的其余所有房间都被锁住。

你可以自由地在房间之间来回走动。

如果能进入每个房间返回 `true`，否则返回 `false`。

示例 1：

```tex
输入: [[1],[2],[3],[]]
输出: true
解释:  
我们从 0 号房间开始，拿到钥匙 1。
之后我们去 1 号房间，拿到钥匙 2。
然后我们去 2 号房间，拿到钥匙 3。
最后我们去了 3 号房间。
由于我们能够进入每个房间，我们返回 true。
```

示例 2：

```tex
输入：[[1,3],[3,0,1],[2],[0]]
输出：false
解释：我们不能进入 2 号房间。
```

提示：

- `1 <= rooms.length <= 1000`
- `0 <= rooms[i].length <= 1000`
- 所有房间中的钥匙数量总计不超过 `3000`。

**解法**：

```java
class Solution {
    public boolean canVisitAllRooms(List<List<Integer>> rooms) {
        int[] visited = new int[rooms.size()];
        Queue<Integer> queue = new LinkedList<Integer> ();

        // 初始化，将 0 入队
        queue.offer(0);

        // 从 0 开始 BFS
        while (!queue.isEmpty()) {
            int index = queue.poll();
            visited[index] = 1;

            // 判断从当前房间能去哪些房间
            List<Integer> list = rooms.get(index);
            for (int i = 0; i < list.size(); i++) {
                if (visited[list.get(i)] == 0) {
                    queue.offer(list.get(i));
                }
            }
        }

        // 判断是否所有房间都被访问过
        for (int i = 0; i < rooms.size(); i++) {
            if (visited[i] == 0) {
                return false;
            }
        }

        return true;
    }
}
```

