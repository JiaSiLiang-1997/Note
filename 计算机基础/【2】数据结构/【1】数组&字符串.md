# 一 简述

**数组**是数据结构中的基本模块之一。因为**字符串**是由字符数组形成的，所以二者是相似的。大多数面试问题都属于这个范畴。

在本 LeetBook 中，我们将介绍**数组**和**字符串**。完成后，你将：

1. 理解数组的**基本概念**及其**操作方式**；
2. 理解**二维数组**的基本概念，熟悉二维数组的使用；
3. 了解**字符串**的概念以及字符串所具有的不同特性；
4. 理解字符串匹配中的**KMP 算法**；
5. 能够运用**双指针**解决实际问题。



# 二 数组简介

本章节中，我们将详细介绍**数组**这种数据结构。

完成本章后，你将能够回答以下问题：

1. 数组和列表、集合之间有什么不同？
2. 如何理解数组的读取、查找、插入、删除等**基本操作**？
3. 数组在内存中是如何存放的？
4. 在你常用的语言中，如何对数组执行初始化、数据访问、修改、迭代、排序、添加、删除等操作？

## 2.1 集合、列表和数组

具体介绍数组之前，我们先来了解一下集合、列表和数组的概念之间的差别。

### 2.1.1 集合

**集合**一般被定义为：由一个或多个确定的元素所构成的整体。

通俗来讲，集合就是将一组事物组合在一起。你可以将力扣的题库看作一个集合：

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210808154237660.png" alt="image-20210808154237660" style="zoom:67%;" />

也可以将力扣商店里的礼品看作一个集合：

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210808154254410.png" alt="image-20210808154254410"  />

甚至可以将桌面上的物品当作一个集合。

集合有什么特性呢？

首先，**集合里的元素类型不一定相同**。 你可以将商品看作一个集合，也可以将整个商店看作一个集合，这个商店中有人或者其他物品也没有关系。

其次，**集合里的元素没有顺序**。 我们不会这样讲：我想要集合中的第三个元素，因为集合是没有顺序的。

事实上，这样的集合并不直接存在于编程语言中。然而，实际编程语言中的很多数据结构，就是在集合的基础上添加了一些规则形成的。



### 2.1.2 列表

**列表**（又称线性列表）的定义为：是一种数据项构成的有限序列，即按照一定的线性顺序，排列而成的数据项的集合。

列表的概念是在集合的特征上形成的，它具有顺序，且长度是可变的。你可以把它看作一张购物清单：

![image-20210808154448243](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210808154448243.png)

在这张清单中：

- 购物清单中的条目代表的类型可能不同，但是按照一定顺序进行了排列；
- 购物清单的长度是可变的，你可以向购物清单中增加、删除条目。

在编程语言中，列表最常见的表现形式有数组和链表，而我们熟悉的栈和队列则是两种特殊类型的列表。除此之外，向列表中添加、删除元素的具体实现方式会根据编程语言的不同而有所区分。



### 2.1.3 数组

数组是列表的实现方式之一，也是面试中经常涉及到的数据结构。

正如前面提到的，数组是列表的实现方式，它具有列表的特征，同时也具有自己的一些特征。然而，在具体的编程语言中，数组这个数据结构的实现方式具有一定差别。比如 C++ 和 Java 中，数组中的元素类型必须保持一致，而 Python 中则可以不同。Python 中的数组叫做 list，具有更多的高级功能。

那么如何从宏观上区分列表和数组呢？这里有一个重要的概念：**索引**。

首先，数组会用一些名为**索引**的数字来标识每项数据在数组中的位置，且在大多数编程语言中，索引是从 0 算起的。我们可以根据数组中的索引，快速访问数组中的元素。

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210808154744762.png" alt="image-20210808154744762" style="zoom:80%;" />

而列表中没有索引，这是数组与列表最大的不同点。

其次，数组中的元素在内存中是连续存储的，且每个元素占用相同大小的内存。要理解这一点，我们需要了解数组在内存中的存储方式，我们将在下一节中详细介绍。

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210808154836976.png" alt="image-20210808154836976" style="zoom:80%;" />

相反，列表中的元素在内存中可能彼此相邻，也可能不相邻。比如列表的另一种实现方式——链表，它的元素在内存中则不一定是连续的。有关链表的介绍，可以在探索卡片「链表」中进行进一步学习。



### 2.1.4 小结

以上就是集合、列表和数组的介绍，你能自己总结出它们的不同点吗？

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210808154925223.png" alt="image-20210808154925223" style="zoom:80%;" />

集合：是列表和数组的原型；

- 特征：无序，不重复。

列表[线性列表]：

- 一种数据项构成的有限序列。按照一定的线性顺序，排列而成的数据项的集合。
- 特征：顺序，长度可变。
  常见表现形式：数组和链表；特殊类型：栈和队列。

数组：

- 列表的实现方式之一；数组是列表的实现方式，具有列表的特征。
- C++&Java：列表中的元素类型必须一致；
- Python：它的数组名字叫做list，并且内部元素类型不尽相同。
- 宏观上区分列表和数组的元素：索引。
- 数组会通过索引来表示每项数据在数组中的位置；列表中没有索引。
- 存储方式：数组中的元素是连续存储，而列表中的元素可以相邻或者不相邻。
  实现方法：链表[不连续]。



## 2.2 数组的操作

### 2.2.1 读取元素

读取数组中的元素，是通过访问索引的方式来读取的，索引一般从 `0` 开始。

在计算机中，内存可以看成一些已经排列好的格子，每个格子对应一个内存地址。一般情况下，数据会分散地存储在不同的格子中。

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210808155722755.png" alt="image-20210808155722755" style="zoom:80%;" />

而对于数组，计算机会在内存中为其申请一段 连续 的空间，并且会记下索引为 `0` 处的内存地址。以数组 `["C", "O", "D", "E", "R"]` 为例，它的各元素对应的索引及内存地址如下图所示。

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210808155759035.png" alt="image-20210808155759035" style="zoom:80%;" />

假如我们想要访问索引为 `2` 处的元素 `"D"` 时，计算机会进行以下计算：

- 找到该数组的索引 `0` 的内存地址： `2008`；
- 将内存地址加上索引值，作为目标元素的地址，即 `2008 + 2 = 2010`，对应的元素为 `"D"`，这时便找到了目标元素。

我们知道，计算内存地址这个过程是很快的，而我们一旦知道了内存地址就可以立即访问到该元素，因此它的时间复杂度是常数级别，为 **O(1)**。



### 2.2.2 查找元素

假如我们对数组中包含哪些元素并不了解，只是想知道其中是否含有元素 `"E"`，数组会如何查找元素 `"E"` 呢？

与读取元素类似，由于我们只保存了索引为 `0` 处的内存地址，因此在查找元素时，只需从数组开头逐步向后查找就可以了。如果数组中的某个元素为目标元素，则停止查找；否则继续搜索直到到达数组的末尾。

<img src="https://pic.leetcode-cn.com/3d9c20552e0e9c4650f4a267f4066aa71338ad0013514559b57a1bf786d662ba-4.gif" alt="4.gif"  />

我们发现，最坏情况下，搜索的元素为 `"R"`，或者数组中不包含目标元素时，我们需要查找 `n` 次，`n` 为数组的长度，因此查找元素的时间复杂度为 **O(N)**，N 为数组的长度。



### 2.2.3 插入元素

假如我们想在原有的数组中再插入一个元素 `"S"` 呢？

如果要将该元素插入到数组的末尾，只需要一步。即计算机通过数组的长度和位置计算出即将插入元素的内存地址，然后将该元素插入到指定位置即可。

![6.gif](https://pic.leetcode-cn.com/2b53523dc1a745d89fbc11ba776eaa2d0f220acf4c232b1a83f939c973141280-6.gif)

然而，如果要将该元素插入到数组中的其他位置，则会有所区别，这时我们首先需要为该元素所要插入的位置 **腾出** 空间，然后进行插入操作。比如，我们想要在索引 `2` 处插入 `"S"`。

![7.gif](https://pic.leetcode-cn.com/22ce7dbf8cd441fd7425499cd8154d1c4211a6a42ec3f3995520ee76ce7183c7-7.gif)

我们发现，如果需要频繁地对数组元素进行插入操作，会造成时间的浪费。事实上，另一种数据结构，即链表可以有效解决这个问题，我们将在另外的卡片中进行学习。



### 2.2.4 删除元素

删除元素与插入元素的操作类似，当我们删除掉数组中的某个元素后，数组中会留下 **空缺** 的位置，而数组中的元素在内存中是连续的，这就使得后面的元素需对该位置进行 **填补** 操作。

以删除索引 `1` 中的元素 `"O"` 为例，具体过程如图所示。

![6.gif](https://pic.leetcode-cn.com/4df7a5a75e5f76b6e7e4540f9403c7c2fee5197a1f30421b4f5d32fdca2cf360-8.gif)

当数组的长度为 `n` 时，最坏情况下，我们删除第一个元素，共需要的步骤数为 `1 + (n - 1) = n` 步，其中，`1` 为删除操作，`n - 1` 为移动其余元素的步骤数。删除操作具有线性时间复杂度，即时间复杂度为 **O(N)**，N 为数组的长度。

### 2.2.5 小结

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210808160710626.png" alt="image-20210808160710626" style="zoom: 50%;" />

数组中的查询

- 按位置查询。时间复杂度：O(1)。索引＋偏移量（下标）
- 按值查询。时间复杂度：O(N)。计算机不知道个位置处的值信息，需要一一查询判断。

数组添加元素

- 时间复杂度：O(N)

删除元素：

- 时间复杂度：O(N)

只考虑最坏情况的时间复杂度



## 2.3 经典例题

### 2.3.1 寻找数组的中心索引[724]

给你一个整数数组 `nums` ，请计算数组的 **中心下标** 。

数组 **中心下标** 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 `0` ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 **最靠近左边** 的那一个。如果数组不存在中心下标，返回 -1 。

 

示例 1：

```tex
输入：nums = [1, 7, 3, 6, 5, 6]
输出：3
解释：
中心下标是 3 。
左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。
```

示例 2：

```tex
输入：nums = [1, 2, 3]
输出：-1
解释：
数组中不存在满足此条件的中心下标。
```


示例 3：

```tex
输入：nums = [2, 1, -1]
输出：0
解释：
中心下标是 0 。
左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），
右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。
```


提示：

- `1 <= nums.length <= 104`
- `-1000 <= nums[i] <= 1000`

**解法**：

```java
// 解法一：暴力求解
class Solution {
    public int pivotIndex(int[] nums) {
            for (int i=0; i< nums.length; i++) {
            int left = 0;
            int right = nums.length - 1;
            int leftSum = numSum(nums, left, i - 1);
            int rightSum = numSum(nums, i + 1, right);
            if (leftSum == rightSum) return i;
        }
        return -1;
    }

    public int numSum(int[] nums, int left, int right) {
        int num = 0;
        for (int i = left; i <= right; i++) {
            num += nums[i];
        }
        return num;
    }
}

// 解法二：前缀和
class Solution {
    public int pivotIndex(int[] nums) {
        int total = Arrays.stream(nums).sum();
        int sum = 0;
        for (int i = 0; i<nums.length; i++) {
            if (2*sum == total - nums[i]) {
                return i;
            }
            sum += nums[i];
        }
        return - 1;
     }
}
```



### 2.3.2 搜索插入位置[35]

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

请必须使用时间复杂度为 O(log n) 的算法。

 

示例 1:

```tex
输入: nums = [1,3,5,6], target = 5
输出: 2
```

示例 2:

```tex
输入: nums = [1,3,5,6], target = 2
输出: 1
```

示例 3:

```tex
输入: nums = [1,3,5,6], target = 7
输出: 4
```

示例 4:

```tex
输入: nums = [1,3,5,6], target = 0
输出: 0
```

示例 5:

```tex
输入: nums = [1], target = 0
输出: 0
```


提示:

- `1 <= nums.length <= 104`
- `-104 <= nums[i] <= 104`
- `nums` 为无重复元素的升序排列数组
- `-104 <= target <= 104`

**解法**：

```java
// 解法一：二分查找
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length -1;
        while (left <= right) {
            int mid = (left + right) / 2;
            if (nums[mid] == target) return mid;
            if (nums[mid] < target) left = mid + 1;
            if (nums[mid] > target) right = mid - 1;
        }
        return left;
    }
}
```



### 2.3.3 合并区间[56]

以数组 intervals 表示若干个区间的集合，其中单个区间为 `intervals[i] = [starti, endi]` 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。

示例 1：

```tex
输入：intervals = [[1,3],[2,6],[8,10],[15,18]]
输出：[[1,6],[8,10],[15,18]]
解释：区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].
```

示例 2：

```tex
输入：intervals = [[1,4],[4,5]]
输出：[[1,5]]
解释：区间 [1,4] 和 [4,5] 可被视为重叠区间。
```


提示：

- `1 <= intervals.length <= 104`
- `intervals[i].length == 2`
- `0 <= starti <= endi <= 104`

**解法**：

```java
class Solution {
    public int[][] merge(int[][] intervals) {
        List<int[]> list = new ArrayList<int[]>();
        intervals =  pubble(intervals);
        int size = intervals.length;
        list.add(intervals[0]);
        for (int i = 1; i < size; i++) {
            int listSize = list.size();
            if (list.get(listSize - 1)[1] >= intervals[i][0]) {
                list.get(listSize - 1)[1] = Math.max(list.get(listSize - 1)[1], intervals[i][1]);
            } else {
                list.add(intervals[i]);
            }
        }
        int[][] result = new int[list.size()][2];
        int i = 0;
        for (int[] vals : list) {
            result[i++] = vals;
        }
        return result;
    }

    public int[][] pubble(int[][] intervals) {
        int size = intervals.length;
        for (int i = 0; i < size - 1; i++) {
            boolean flag = true;
            for(int j = 0; j < size - i - 1; j++) {
                if (intervals[j][0] >  intervals[j + 1][0]) {
                    swap(intervals[j], intervals[j+1]);
                    flag = false;
                }
            }
            if (flag == true) break;
        }
        return intervals;
    }

    public void swap(int[] a, int[] b) {
        int tempStart = a[0];
        int tempEnd = a[1];
        a[0] = b[0];
        a[1] = b[1];
        b[0] = tempStart;
        b[1] = tempEnd;
    }
}
// 优化后
class Solution {
    public int[][] merge(int[][] intervals) {
        if (intervals.length == 0) {
            return new int[0][2];
        }
        Arrays.sort(intervals, new Comparator<int[]>() {
            public int compare(int[] interval1, int[] interval2) {
                return interval1[0] - interval2[0];
            }
        });
        List<int[]> merged = new ArrayList<int[]>();
        for (int i = 0; i < intervals.length; ++i) {
            int L = intervals[i][0], R = intervals[i][1];
            if (merged.size() == 0 || merged.get(merged.size() - 1)[1] < L) {
                merged.add(new int[]{L, R});
            } else {
                merged.get(merged.size() - 1)[1] = Math.max(merged.get(merged.size() - 1)[1], R);
            }
        }
        return merged.toArray(new int[merged.size()][]);
    }
}
```

# 三 二维数组简介

前面的章节中，我们已经了解了 一维数组。然而，有时候，我们可能需要用到 多维数组，它更适合像表或矩阵这样更复杂的结构。

本章节中，我们将重点围绕二维数组来解释：

1. 二维数组在内存中是如何存放的？
2. 如何运用二维数组来解决问题？

## 3.1 二维数组简介

二维数组是一种结构较为特殊的数组，只是将数组中的每个元素变成了一维数组。

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210809110310990.png" alt="image-20210809110310990" style="zoom:80%;" />

所以二维数组的本质上仍然是一个一维数组，内部的一维数组仍然从索引 `0` 开始，我们可以将它看作一个矩阵，并处理矩阵的相关问题。

**示例**

类似一维数组，对于一个二维数组 `A = [[1, 2, 3, 4],[2, 4, 5, 6],[1, 4, 6, 8]]`，计算机同样会在内存中申请一段 **连续** 的空间，并记录第一行数组的索引位置，即 `A[0][0]` 的内存地址，它的索引与内存地址的关系如下图所示。

<img src="https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20210809110439853.png" alt="image-20210809110439853" style="zoom:80%;" />

注意，实际数组中的元素由于类型的不同会占用不同的字节数，因此每个方格地址之间的差值可能不为 `1`。

实际题目中，往往使用二维数组处理矩阵类相关问题，包括矩阵旋转、对角线遍历，以及对子矩阵的操作等。



## 3.2 经典例题

### 3.2.1 旋转图像[48]

给你一幅由 N × N 矩阵表示的图像，其中每个像素的大小为 4 字节。请你设计一种算法，将图像旋转 90 度。

不占用额外内存空间能否做到？

 

示例 1:

```tex
给定 matrix = 
[
  [1,2,3],
  [4,5,6],
  [7,8,9]
],

原地旋转输入矩阵，使其变为:
[
  [7,4,1],
  [8,5,2],
  [9,6,3]
]
```

示例 2:

```tex
给定 matrix =
[
  [ 5, 1, 9,11],
  [ 2, 4, 8,10],
  [13, 3, 6, 7],
  [15,14,12,16]
], 

原地旋转输入矩阵，使其变为:
[
  [15,13, 2, 5],
  [14, 3, 4, 1],
  [12, 6, 8, 9],
  [16, 7,10,11]
]
```

**解法**：

```java
class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;
        int k = n / 2;
        for (int i=0; i < k; i++) {
            int m = (n - 2*i - 2);
            int start = i + 1;
            int end = n - 1 - i - 1;
            for (int j=0; j < m; j++) {
                int up = matrix[i][start + j];
                int left = matrix[end-j][i];
                int down = matrix[n-1-i][end-j];
                int right = matrix[start + j][n-1-i];

                // 旋转
                matrix[i][start + j] = left;
                matrix[end-j][i] = down;
                matrix[n-1-i][end-j] = right;
                matrix[start + j][n-1-i] = up;
            }
            // 旋转4个顶点
            int leftUp = matrix[i][i];
            int rightUp = matrix[i][n-1-i];
            int leftDown = matrix[n-1-i][i];
            int rightDown = matrix[n-1-i][n-1-i];

            matrix[i][i] = leftDown;
            matrix[i][n-1-i] = leftUp;
            matrix[n-1-i][i] = rightDown;
            matrix[n-1-i][n-1-i] = rightUp;
        }
    }
}
```



### 3.2.2 零矩阵[面试题 01.08]

编写一种算法，若M × N矩阵中某个元素为0，则将其所在的行与列清零。

示例 1：

```tex
输入：
[
  [1,1,1],
  [1,0,1],
  [1,1,1]
]
输出：
[
  [1,0,1],
  [0,0,0],
  [1,0,1]
]
```

示例 2：

```tex
输入：
[
  [0,1,2,0],
  [3,4,5,2],
  [1,3,1,5]
]
输出：
[
  [0,0,0,0],
  [0,4,5,0],
  [0,3,1,0]
]
```

**解法**：

```java
class Solution {
    public void setZeroes(int[][] matrix) {
        Map<Integer, Integer> mapRow = new HashMap<Integer, Integer>();
        Map<Integer, Integer> mapCol = new HashMap<Integer, Integer>();
        for (int i = 0; i < matrix.length; i++) {
            for (int j = 0; j < matrix[0].length; j++) {
                if (matrix[i][j] == 0) {
                    mapRow.put(i, 1);mapCol.put(j, 1);
                }
            }
        }

        Iterator<Integer> setRow = mapRow.keySet().iterator();
        while(setRow.hasNext()) {
            int row = setRow.next();
            for (int i = 0; i < matrix[0].length; i++) {
                matrix[row][i] = 0;
            }
        }

        Iterator<Integer> setCol = mapCol.keySet().iterator();
        while(setCol.hasNext()) {
            int col = setCol.next();
            for (int i = 0; i < matrix.length; i++) {
                matrix[i][col] = 0;
            }
        }
    }
}

// 优化后
class Solution {
    public void setZeroes(int[][] matrix) {
        int m = matrix.length, n = matrix[0].length;
        boolean[] row = new boolean[m];
        boolean[] col = new boolean[n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (matrix[i][j] == 0) {
                    row[i] = col[j] = true;
                }
            }
        }
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (row[i] || col[j]) {
                    matrix[i][j] = 0;
                }
            }
        }
    }
}
```

### 3.2.3 对角线遍历[498]

给定一个含有 M x N 个元素的矩阵（M 行，N 列），请以对角线遍历的顺序返回这个矩阵中的所有元素，对角线遍历如下图所示。

**示例:**

```
输入:
[
 [ 1, 2, 3 ],
 [ 4, 5, 6 ],
 [ 7, 8, 9 ]
]

输出:  [1,2,4,7,5,3,6,8,9]

解释:
```

**说明:**

1. 给定矩阵中的元素总数不会超过 100000 。

**解法**：

```java
class Solution {
    public int[] findDiagonalOrder(int[][] mat) {
        int M = mat.length - 1;
        int N = mat[0].length - 1;
        int k = M + N + 1;
        int[] ans = new int[mat.length * mat[0].length];
        int n = 0;
        for (int i = 0; i < k; i++) {
            if (i % 2 == 0) {
                for (int j = Math.min(i, M); j >= 0; j--) {
                    for (int m = 0; m <= N; m++){
                        if (j + m == i) {
                            ans[n++] = mat[j][m];
                        }
                    }
                }
            } else {
                for (int j = 0; j <= M; j++) {
                    for (int m = Math.min(i, N); m >= 0; m--) {
                        if (j + m == i) {
                            ans[n++] = mat[j][m];
                        }
                    }
                }
            }
        }
        return ans;
    }
}

// 优化
class Solution {
    public int[] findDiagonalOrder(int[][] mat) {
        if(mat.length == 0) return new int[0];
        int m = mat.length, n = mat[0].length;
        int[] res = new int[m * n];
        int idx = 0;
        int row = 0, col = 0;
        for(int i = 0; i < m + n - 1; i++) {
            if((i & 1) == 0) { // 0 2 4 6 
                while(row >= 0 && col < n) {
                    res[idx++] = mat[row--][col++];
                }
                if(col < n) {
                    row++;
                } else {
                    row += 2;
                    col--;
                }
            } else { // 1 3 5 7
                while(row < m && col >= 0) {
                    res[idx++] = mat[row++][col--];
                }
                if(row < m) {
                    col++;
                } else {
                    col += 2;
                    row--;
                }
            }
        }
        return res;
    }
}
```



# 四 字符串简介

正如我们在概述中提到的那样，字符串是一个由字符构成的数组。

本章节中，我们将深入研究字符串。完成本章后，你将：

1. 熟悉字符串中的 **基本操作**，尤其是在数组中没有的独特操作；
2. 理解不同 **比较** 函数之间的区别；
3. 理解字符串 **是否可变** 以及导致连接过程中出现的问题；
4. 能够解决与字符串相关的基本问题，如排序、子串、字符串匹配等。

## 4.1 字符串简介

字符串是由零个或多个字符组成的有限序列。一般记为` s = a1a2...an`。它是编程语言中表示文本的数据类型。

###  4.1.1 为何单独讨论字符串类型

我们知道，字符串与数组有很多相似之处，比如使用 **名称[下标]** 来得到一个字符。那么我们为什么要单独讨论字符串呢？原因主要有：

1. 字符串的基本操作对象通常是字符串整体或者其子串

例如有这样一个字符串序列：`I like leetcode` 现在你想把这句话反向输出，可能会变成这样：

`edocteel ekil I`

这是我们想要的结果吗？你可能会回答不是，因为它没有任何意义。我们通常希望单词仍然维持原来的顺序，这样反向输出之后就是：

`Leetcode like I`

这样的结果对于我们来讲是不是更满意呢？维持单词本身的顺序使得我们方便进行更多操作，这里的每个单词就叫做字符串的「子串」，通常，我们的操作对象更多情况下是这些子串。

2. 字符串操作比其他数据类型更复杂（例如比较、连接操作）

对于不同的编程语言，字符串的某些操作会有所不同。下面我们将从字符串的「比较」和「连接」操作两个方面分别进行讲解。



### 4.1.2 比较函数

字符串有它自己的比较函数（我们将在下面的代码中向你展示比较函数的用法）。

然而，存在这样一个问题：

> 我们可以用 “==” 来比较两个字符串吗？

这取决于下面这个问题的答案：

> 我们使用的语言是否支持运算符重载？

- 如果答案是 yes （例如 C++、Python）。我们可以使用 == 来比较两个字符串；
- 如果答案是 no （例如 Java），我们可能无法使用 == 来比较两个字符串。当我们使用 == 时，它实际上会比较这两个对象是否是同一个对象。

你可以运行下面的例子来比较结果：

```java
// "static void main" must be defined in a public class.
public class Main {
    public static void main(String[] args) {
        // initialize
        String s1 = "Hello World";
        System.out.println("s1 is \"" + s1 + "\"");
        String s2 = s1;
        System.out.println("s2 is another reference to s1.");
        String s3 = new String(s1);
        System.out.println("s3 is a copy of s1.");
        // compare using '=='
        System.out.println("Compared by '==':");
        // true since string is immutable and s1 is binded to "Hello World"
        System.out.println("s1 and \"Hello World\": " + (s1 == "Hello World"));
        // true since s1 and s2 is the reference of the same object
        System.out.println("s1 and s2: " + (s1 == s2));
        // false since s3 is refered to another new object
        System.out.println("s1 and s3: " + (s1 == s3));
        // compare using 'equals'
        System.out.println("Compared by 'equals':");
        System.out.println("s1 and \"Hello World\": " + s1.equals("Hello World"));
        System.out.println("s1 and s2: " + s1.equals(s2));
        System.out.println("s1 and s3: " + s1.equals(s3));
        // compare using 'compareTo'
        System.out.println("Compared by 'compareTo':");
        System.out.println("s1 and \"Hello World\": " + (s1.compareTo("Hello World") == 0));
        System.out.println("s1 and s2: " + (s1.compareTo(s2) == 0));
        System.out.println("s1 and s3: " + (s1.compareTo(s3) == 0));
    }
}
```

### 4.1.3 连接操作

对于不同的编程语言中，字符串可能是可变的，也可能是不可变的。不可变意味着一旦字符串被初始化，你就无法改变它的内容。

- 在某些语言（如 C ++）中，字符串是可变的。 也就是说，你可以像在数组中那样修改字符串。
- 在其他一些语言（如 Java、Python）中，字符串是不可变的。

你可以通过测试修改操作来确定你喜欢的语言中的字符串是否可变。这里有一个示例：

```java
// "static void main" must be defined in a public class.
public class Main {
    public static void main(String[] args) {
        String s1 = "Hello World";
        s1[5] = ',';
        System.out.println(s1);
    }
}
```

在 **字符串不可变** 的语言中，进行字符串的连接操作则会带来一些问题。

显然，不可变字符串无法被修改。哪怕你只是想修改其中的一个字符，也必须创建一个新的字符串。我们以 Java 为例，来看一个在 for 循环中重复进行字符串连接的例子：

```java
// "static void main" must be defined in a public class.
public class Main {
    public static void main(String[] args) {
        String s = "";
        int n = 10000;
        for (int i = 0; i < n; i++) {
            s += "hello";
        }
    }
}
```

我们发现在 C++ 中，进行字符串连接并没有明显的性能影响。

然而，对于 Java来说，由于字符串是不可变的，因此在连接时首先为新字符串分配足够的空间，复制旧字符串中的内容并附加到新字符串。

因此，总时间复杂度将是：

5+5×2+5×3+…+5×*n*=5×(1+2+3+…+*n*)=5×*n*×(*n*+1)/2  即O(**N^2**)。

针对 Java 中出现的此问题，我们提供了以下解决方案：

- 如果你确实希望你的字符串是可变的，则可以使用 `toCharArray()` 将其转换为字符数组。
- 如果你经常必须连接字符串，最好使用一些其他的数据结构，如 `StringBuilder` 。



## 4.2 经典例题

### 4.2.1 最长公前缀[14]

难度简单1719收藏分享切换为英文接收动态反馈

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

**示例 1：**

```
输入：strs = ["flower","flow","flight"]
输出："fl"
```

**示例 2：**

```
输入：strs = ["dog","racecar","car"]
输出：""
解释：输入不存在公共前缀。
```

**提示：**

- `1 <= strs.length <= 200`
- `0 <= strs[i].length <= 200`
- `strs[i]` 仅由小写英文字母组成

**解法**：

```java
// 纵向扫描
class Solution {
    public String longestCommonPrefix(String[] strs) {
        int len = strs.length;
        int minLen = 200;
        for (int i = 0; i < len; i++) {
            int strlen = strs[i].length();
            if (minLen > strlen) {
                minLen = strlen;
            }
        }
        int count = -1;
        for (int i = 0; i < minLen; i++) {
            boolean flag = true;
            for (int j = 1; j < len; j++) {
                if (strs[j].charAt(i) != strs[0].charAt(i)) {
                    flag = false;
                    break;
                }
            }
            if (!flag) {
                break;
            }
            count++;
        }
        if (count >=0 ) {
            return strs[0].subSequence(0, count + 1).toString();
        } else {
            return "";
        }
    }
}
// 优化：横向扫描
class Solution {
    public String longestCommonPrefix(String[] strs) {
        //字符串数组只含有一个字符串时,其本身就是公共最长前缀
        if (strs.length == 1) return strs[0];
        //以strs[0]为公共前缀
        String common = strs[0];
        for (int i = 1; i < strs.length; i++) {
            while (!strs[i].startsWith(common)) {
                //从后往前一直缩小公共前缀,直到匹配或者字符串为空为止!
                common = common.substring(0, common.length() - 1);
                if (common.equals("")) break;
            }
        }
        return common;
    }
}
```

### 4.2.2 最长回文子串[5]

给你一个字符串 `s`，找到 `s` 中最长的回文子串。

**示例 1：**

```
输入：s = "babad"
输出："bab"
解释："aba" 同样是符合题意的答案。
```

**示例 2：**

```
输入：s = "cbbd"
输出："bb"
```

**示例 3：**

```
输入：s = "a"
输出："a"
```

**示例 4：**

```
输入：s = "ac"
输出："a"
```

**提示：**

- `1 <= s.length <= 1000`
- `s` 仅由数字和英文字母（大写和/或小写）组成

**解法**：

```java
// 此方法可以求解答案，但会超时
class Solution {
    public String longestPalindrome(String s) {
        // 找出所有子串保存在 哈希表中；
        Map<String, Integer> map = new HashMap<>();
        String longest = s.subSequence(0, 1).toString();
        int len = s.length();
        for (int i = 0; i < len; i++) {
            for (int j = i; j < len; j++) {
                String temp = s.subSequence(i, j + 1).toString();
                if (judgePalindrome(temp)) {
                    if (temp.length() > longest.length()) {
                        longest = temp;
                    }
                 }
            }
        }
        return longest;
    }

    public boolean judgePalindrome(String s) {
        int len = s.length();
        if (len == 1) {
            return true;
        }
        int mid = len / 2;
        int i = 0;
        for (; i < mid; i++) {
            if (s.charAt(i) != s.charAt(len - 1 - i)) break;
        }
        if (i == mid) {
            return true;
        } else {
            return false;
        }
    }
}

// 优化 动态规划
public class Solution {

    public String longestPalindrome(String s) {
        int len = s.length();
        if (len < 2) {
            return s;
        }

        int maxLen = 1;
        int begin = 0;
        // dp[i][j] 表示 s[i..j] 是否是回文串
        boolean[][] dp = new boolean[len][len];
        // 初始化：所有长度为 1 的子串都是回文串
        for (int i = 0; i < len; i++) {
            dp[i][i] = true;
        }

        char[] charArray = s.toCharArray();
        // 递推开始
        // 先枚举子串长度
        for (int L = 2; L <= len; L++) {
            // 枚举左边界，左边界的上限设置可以宽松一些
            for (int i = 0; i < len; i++) {
                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                int j = L + i - 1;
                // 如果右边界越界，就可以退出当前循环
                if (j >= len) {
                    break;
                }

                if (charArray[i] != charArray[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substring(begin, begin + maxLen);
    }
}
```



### 4.2.3 翻转字符串里的单词[151]

给你一个字符串 `s` ，逐个翻转字符串中的所有 **单词** 。

**单词** 是由非空格字符组成的字符串。`s` 中使用至少一个空格将字符串中的 **单词** 分隔开。

请你返回一个翻转 `s` 中单词顺序并用单个空格相连的字符串。

**说明：**

- 输入字符串 `s` 可以在前面、后面或者单词间包含多余的空格。
- 翻转后单词间应当仅用一个空格分隔。
- 翻转后的字符串中不应包含额外的空格。

**示例 1：**

```
输入：s = "the sky is blue"
输出："blue is sky the"
```

**示例 2：**

```
输入：s = "  hello world  "
输出："world hello"
解释：输入字符串可以在前面或者后面包含多余的空格，但是翻转后的字符不能包括。
```

**示例 3：**

```
输入：s = "a good   example"
输出："example good a"
解释：如果两个单词间有多余的空格，将翻转后单词间的空格减少到只含一个。
```

**示例 4：**

```
输入：s = "  Bob    Loves  Alice   "
输出："Alice Loves Bob"
```

**示例 5：**

```
输入：s = "Alice does not even like bob"
输出："bob like even not does Alice"
```

**提示：**

- `1 <= s.length <= 104`
- `s` 包含英文大小写字母、数字和空格 `' '`
- `s` 中 **至少存在一个** 单词

**解法**：

```java
class Solution {
    public String reverseWords(String s) {
        // 首先找到所有的单词
        int len = s.length();
        int wordLen = 0;
        char[] charArray = s.toCharArray();
        Stack<String> stack = new Stack<>();
        int i = 0;
        for (; i < len; i++) {
            if (charArray[i] == ' ') {
                if (wordLen != 0) {
                    stack.push(s.substring(i - wordLen, i));
                    wordLen = 0;
                }
            } else {
                wordLen++;
            }
        }
        stack.push(s.substring(i - wordLen, i));

        String ans = "";
        while(!stack.empty()) {
            String val = stack.pop();
            if (!val.equals("")) {
                ans = ans + val + " ";
            }
        }
        ans = ans.substring(0, ans.length()-1);
        return ans;
    }
}
// 优化
class Solution {
    public String reverseWords(String s) {
        int left = 0,right = s.length() - 1;
        while(left <= right && s.charAt(left) == ' '){
            left++;
        }
        while(left <= right && s.charAt(right) == ' '){
            right--;
        }
        Deque<String> d = new LinkedList<>();
        StringBuilder sb = new StringBuilder();
        while(left <= right){
            char c = s.charAt(left);
            if(sb.length() != 0 && c == ' '){
                d.offerFirst(sb.toString());
                sb.setLength(0);
            }else if(c != ' '){
                sb.append(c);
            }
            left++;
        }
        d.offerFirst(sb.toString());
        return String.join(" ",d);
    }
}
```

## 4.3 KMP算法

Knuth–Morris–Pratt（KMP）算法是一种改进的字符串匹配算法，它的核心是利用匹配失败后的信息，尽量减少模式串与主串的匹配次数以达到快速匹配的目的。它的时间复杂度是 O(**m+n**)。

这段话你可能并不理解。没关系，我们来看一个例子。

### 4.3.1 情景 1

假如你是一名生物学家，现在，你的面前有两段 DNA 序列 `S` 和 `T`，你需要判断 `T` 是否可以匹配成为 `S` 的子串。

<img src="https://pic.leetcode-cn.com/9e5ef680e9e8dd2b038e32e88abea44ca6fb0b32994de57d26562751bb5d7ba8-1.png" alt="1.png" style="zoom: 33%;" />

你可能会凭肉眼立即得出结论：是匹配的。可是计算机没有眼睛，只能对每个字符进行逐一比较。

对于计算机来讲，首先它会从左边第一个位置开始进行逐一比较：

<img src="https://pic.leetcode-cn.com/9ba3e12042e13d412f00166eca79c6aad1ada7ccf1e0fd2134793833f4d06624-1.gif" alt="2.gif" style="zoom: 25%;" />

这样，当匹配到 `T` 的最后一个字符时，发现不匹配，于是从 `S` 的第二个字符开始重新进行比较：

<img src="https://pic.leetcode-cn.com/71bda4bc896e8482ef218023a63ba1c6d1a5f8ab8477f8ea122ac5517a1ea880-2.gif" alt="2.gif" style="zoom:25%;" />

仍然不匹配，再次将 `T` 与 `S` 的第三个字符开始匹配......不断重复以上步骤，直到从 `S` 的第四个字符开始时，最终得出结论：`S` 与 `T` 是匹配的。

<img src="https://pic.leetcode-cn.com/6ed2dcacd3f9de2106eee74f71c78d25ef97e49deb0f3c926d034f4e96ad5b75-3.gif" alt="3.gif" style="zoom:25%;" />


你发现这个方法的弊端了吗？我们在进行每一轮匹配时，总是会重复对 `A` 进行比较。也就是说，对于 `S` 中的每个字符，我们都需要从 `T` 第一个位置重新开始比较，并且 `S` 前面的 `A` 越多，浪费的时间也就越多。假设 `S` 的长度为 `m`，`T` 的长度为 `n`，理论上讲，最坏情况下迭代 `m−n+1` 轮，每轮最多进行 `n` 次比对，一共比较了 `(m−n+1)×n` 次，当 `m>>n` 时，渐进时间复杂度为 O(**mn**)。

而 KMP 算法的好处在于，它可以将时间复杂度降低到 O(**m+n**)，字符序列越长，该算法的优势越明显。它是怎么实现的呢？

### 4.3.2 情景 2

再来举一个例子，现在有如下字符串 `S` 和 `P`，判断 `P` 是否为 `S` 的子串。

<img src="https://pic.leetcode-cn.com/8232d8903a6cd53995950805ed6e9747f51f6492eb9dfe46e183a72706788170-4.png" alt="4.png" style="zoom: 33%;" />

我们仍然按照原来的方式进行比较，比较到 `P` 的末尾时，我们发现了不匹配的字符。

<img src="https://pic.leetcode-cn.com/c3dde6e8b72414a720ca76849b4aee32a5ab4833a58388637cae2ad657d4130d-4.gif" alt="4.gif" style="zoom: 25%;" />

注意，按照原来的思路，我们下一步应将字符串 `P` 的开头，与字符串 `S` 的第二位 `C` 重新进行比较。而 KMP 算法告诉我们，我们只需将**字符串 `P` 需要比较的位置重置到图中 `j` 的位置，`S` 保持 `i` 的位置不变**，接下来即可从 `i`，`j` 位置继续进行比较。

<img src="https://pic.leetcode-cn.com/98463d52c63ba4ca59d2099f00fe59b42a8669a7bc38349817899001d442c550-5.png" alt="5.png" style="zoom: 33%;" />

为什么？我们发现字符串 `P` 有子串 `ACT` 和 `ACY`，当 `T` 和 `Y` 不匹配时，我们就确定了 `S` 中的蓝色 `AC` 并不匹配` P` 右侧的 `AC`，但是可能匹配左侧的 `AC`，所以我们从位置 `i` 和 `j` 继续比较。

换句话说，`Y` 对应下标 `2`，表示下一步要重新开始的地方。

既然如此，如果每次不匹配的时候，我们都能立刻知道 `P` 中不匹配的元素，下一步应该从哪个下标重新开始，这样不就能大大简化匹配过程了吗？这就是 KMP 的核心思想。

KMP 算法中，使用一个数组 `next` 来保存 `P` 中元素不匹配时，下一步应该重新开始的下标。由于计算机不能像我们人类一样，通过视觉来得出结论，因此这里有一种适合计算机的构造 `next` 数组的方法。

### 4.3.3 构造 next 数组

构造方法为：**`next[i]` 对应的下标，为 `P[0...i - 1]` 的最长公共前缀后缀的长度，令 `P[0] = -1`**。 具体解释如下：

例如对于字符串 `abcba`：

前缀：它的前缀包括：`a`, `ab`, `abc`, `abcb`，不包括本身；
后缀：它的后缀包括：`bcba`, `cba`, `ba`, `a`，不包括本身；
最长公共前缀后缀：`abcba` 的前缀和后缀中只有 `a` 是公共部分，字符串 `a` 的长度为 `1`。
所以，我们将 `P[0...i - 1]` 的最长公共前后缀的长度作为 `next[i]` 的下标，就得到了 `next` 数组。

<img src="https://pic.leetcode-cn.com/8cd158c08b74130068b580d6d8830ecb700af1e84897ac07a6c533b9c6c0c6a6-8.png" alt="8.png" style="zoom: 33%;" />

### 4.3.4 回到情景 2

我们将思绪切换回来，上次我们还停留在位置 `i` 和 `j`，现在继续进行比较。从如下图所示，由于我们已经构造了 `next` 数组，当继续移动到图中的 `r` 和 `c` 位置时，发现不匹配，根据 `next` 数组，我们可以立即将位置 `c` 回到下标 `0` 的位置：

<img src="https://pic.leetcode-cn.com/bce64b7c2d5632cf519725dc61818d60357464f16b7a6472bb7becc2db0e8438-7.png" alt="7.png" style="zoom:50%;" />


之后的情形就很简单了：

- `K` 与 `A` 不匹配，查看 `next` 数组，`A` 对应 `next` 中的元素为 `-1`，表示不动，`r` 加 `1`；
- 位置 `r` 字符与位置 `c` 字符匹配，继续比较下一位；
- 后面元素均匹配，最终找到匹配元素。

以上就是 KMP 算法的思想，现在回过头来看文章开头的第一句话，你是否有更加深刻的理解了呢？

### 4.3.4 相关代码

KMP 主算法参考代码：

```c++
int match (char* P, char* S){ // KMP 算法
    int* next = buildNext(P); // 构造 next 表
    int m = (int) strlen (S), i = 0; // 文本串指针
    int n = (int) strlen(P), j = 0; //模式串指针
    while (j < n && i < m) // 自左向右逐个比对字符
        if (0 > j || S[i] == P[j]) // 若匹配，或 P 已移除最左侧
            {i++; j++;} // 则转到下一字符
        else
            j = next[j]; // 模式串右移（注意：文本串不用回退）
    delete [] next; // 释放 next 表
    return i - j;
}
```

构造 next 表参考代码：

```c++
int* buildNext(char* P) { // 构造模式串 P 的 next 表
    size_t m = strlen(P), j = 0; // “主”串指针
    int* N = new int[m]; // next 表
    int  t = N[0] = -1; // 模式串指针
    while (j < m - 1)
        if ( 0 > t || P[j] == P[t]){ // 匹配
            j++; t++;
            N[j] = t; // 此句可改进为 N[j] = (P[j] != P[t] ? t : N[t]);
        }else // 失配
        t = N[t];
    return N;

}
```



### 4.3.5 实现 strStr()[28]

实现 [strStr()](https://baike.baidu.com/item/strstr/811469) 函数。

给你两个字符串 `haystack` 和 `needle` ，请你在 `haystack` 字符串中找出 `needle` 字符串出现的第一个位置（下标从 0 开始）。如果不存在，则返回 `-1` 。

**说明：**

当 `needle` 是空字符串时，我们应当返回什么值呢？这是一个在面试中很好的问题。

对于本题而言，当 `needle` 是空字符串时我们应当返回 0 。这与 C 语言的 [strstr()](https://baike.baidu.com/item/strstr/811469) 以及 Java 的 [indexOf()](https://docs.oracle.com/javase/7/docs/api/java/lang/String.html#indexOf(java.lang.String)) 定义相符。

**示例 1：**

```
输入：haystack = "hello", needle = "ll"
输出：2
```

**示例 2：**

```
输入：haystack = "aaaaa", needle = "bba"
输出：-1
```

**示例 3：**

```
输入：haystack = "", needle = ""
输出：0
```

**提示：**

- `0 <= haystack.length, needle.length <= 5 * 104`
- `haystack` 和 `needle` 仅由小写英文字符组成

**解法**：

```java
class Solution {
    public int strStr(String haystack, String needle) {
        int m = haystack.length(), i = 0;
        int n = needle.length(), j = 0;
        if (n==0) {
            return 0;
        }
        if (m < n) return -1;
        int[] next = buildNext(needle);
        while (j < n && i < m) {
            if ( j < 0 || haystack.charAt(i) == needle.charAt(j)) {
                i++;
                j++;
            } else {
                j = next[j];
            }
        }
        if ( i >= m && j < n) {
            return -1;
        } else {
            return i - j;
        }
    }

    public int[] buildNext(String needle) {
        int j = 0;
        int m = needle.length();
        int t = -1;
        int[] next = new int[m];
        next[0] = -1;
        while (j < m - 1) {
            if ( 0 > t || needle.charAt(j) == needle.charAt(t) ) {
                j++;
                t++;
                next[j] = t;
            } else {
                t = next[t];
            }
        }
        return next;
    }
}
```



# 五 双指针技巧

完成前面的章节后，我们现在已经熟悉了数组和字符串的概念，并且能够在数组或字符串中执行基本操作。

通过执行这些操作，我们可以解决一些基本问题。但这显然是不够的。

本章节中，我们将探讨 **双指针技巧**，它可以帮助我们解决许多与数组/字符串相关的问题。

## 5.1 情景一

在上一章中，我们通过迭代数组来解决一些问题。通常，我们只需要一个指针进行迭代，即从数组中的第一个元素开始，最后一个元素结束。然而，有时我们会使用两个指针进行迭代。

<img src="https://pic.leetcode-cn.com/bfdf27723d1b26ee06a56adbf6206fb9d1f7446e297ce05e74e0275b268cd945-1.png" alt="1.png" style="zoom:33%;" />

让我们从一个经典问题开始：

>反转数组中的元素。比如数组为 `['l', 'e', 'e', 't', 'c', 'o', 'd', 'e']`，反转之后变为 `['e', 'd', 'o', 'c', 't', 'e', 'e', 'l']`。

使用双指针技巧，其思想是分别将两个指针分别指向数组的开头及末尾，然后将其指向的元素进行交换，再将指针向中间移动一步，继续交换，直到这两个指针相遇。

**小结**：

我们来总结一下，使用双指针的典型场景之一是你想要

> 从两端向中间迭代数组。

这时你可以使用双指针技巧：

> 一个指针从头部开始，而另一个指针从尾部开始。

这种技巧经常在排序数组中使用。



## 5.2 经典例题

### 5.2.1 反转字符串[344]

编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `char[]` 的形式给出。

不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。

你可以假设数组中的所有字符都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符。

**示例 1：**

```
输入：["h","e","l","l","o"]
输出：["o","l","l","e","h"]
```

**示例 2：**

```
输入：["H","a","n","n","a","h"]
输出：["h","a","n","n","a","H"]
```

**解法**：

```java
class Solution {
    public void reverseString(char[] s) {
        int left = 0;
        int right = s.length - 1;
        while (left < right) {
            char temp = s[left];
            s[left++] = s[right];
            s[right--] = temp;
        }
    }
}
```



### 5.2.2 数组拆分 I [561]

给定长度为 `2n` 的整数数组 `nums` ，你的任务是将这些数分成 `n` 对, 例如 `(a1, b1), (a2, b2), ..., (an, bn)` ，使得从 `1` 到 `n` 的 `min(ai, bi)` 总和最大。

返回该 **最大总和** 。

**示例 1：**

```
输入：nums = [1,4,3,2]
输出：4
解释：所有可能的分法（忽略元素顺序）为：
1. (1, 4), (2, 3) -> min(1, 4) + min(2, 3) = 1 + 2 = 3
2. (1, 3), (2, 4) -> min(1, 3) + min(2, 4) = 1 + 2 = 3
3. (1, 2), (3, 4) -> min(1, 2) + min(3, 4) = 1 + 3 = 4
所以最大总和为 4
```

**示例 2：**

```
输入：nums = [6,2,6,5,1,2]
输出：9
解释：最优的分法为 (2, 1), (2, 5), (6, 6). min(2, 1) + min(2, 5) + min(6, 6) = 1 + 2 + 6 = 9
```

**提示：**

- `1 <= n <= 104`
- `nums.length == 2 * n`
- `-104 <= nums[i] <= 104`

**解法**：

```java
class Solution {
    public int arrayPairSum(int[] nums) {
        Arrays.sort(nums);
        int ans = 0;
        for (int i = 0; i < nums.length; i += 2) {
            ans += nums[i];
        }
        return ans;
    }
}
```



### 5.2.3 两数之和 II - 输入有序数组[167]

给定一个已按照 **升序排列** 的整数数组 `numbers` ，请你从数组中找出两个数满足相加之和等于目标数 `target` 。

函数应该以长度为 `2` 的整数数组的形式返回这两个数的下标值*。*`numbers` 的下标 **从 1 开始计数** ，所以答案数组应当满足 `1 <= answer[0] < answer[1] <= numbers.length` 。

你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。

**示例 1：**

```
输入：numbers = [2,7,11,15], target = 9
输出：[1,2]
解释：2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2 。
```

**示例 2：**

```
输入：numbers = [2,3,4], target = 6
输出：[1,3]
```

**示例 3：**

```
输入：numbers = [-1,0], target = -1
输出：[1,2]
```

 

**提示：**

- `2 <= numbers.length <= 3 * 104`
- `-1000 <= numbers[i] <= 1000`
- `numbers` 按 **递增顺序** 排列
- `-1000 <= target <= 1000`
- 仅存在一个有效答案

**解法**：

```java
// 解法一：二分查找
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int n = numbers.length;
        int i = 0;
        while (2 * numbers[i] <= target && i < n) {
            int left = i + 1;
            int right = n - 1;
            while (left <= right) {
                int mid = (left + right) / 2;
                if (numbers[mid] == target - numbers[i]) return new int[] {i + 1, mid + 1};
                if (numbers[mid] > target - numbers[i]) right = mid - 1;
                else left = mid + 1;
            }
            i++;
        }
        return new int[] {-1, -1};
    }
}
// 解法二：双指针
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int i = 0;
        int j = numbers.length - 1;
        while (i < j) {
            if (numbers[i] + numbers[j] == target) return new int[] {i + 1, j + 1};
            else if (numbers[i] + numbers[j] > target) j--;
            else i++;
        }
        return new int[] {-1, -1};
    }
}
```

## 5.3 情景二

有时，我们可以使用两个不同步的指针来解决问题，即**快慢指针**。与情景一不同的是，两个指针的运动方向是相同的，而非相反。

让我们从一个经典问题开始：

>给你一个数组 `nums` 和一个值 `val`，你需要 **原地** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

如果我们没有空间复杂度上的限制，那就更容易了。我们可以初始化一个新的数组来存储答案。如果元素不等于给定的目标值，则迭代原始数组并将元素添加到新的数组中。

<img src="https://pic.leetcode-cn.com/3f8b23cdbbb25f753c89a309a2860081e0dbb7d7097a2664100849424b07235a-3.png" alt="3.png" style="zoom: 40%;" />

实际上，它相当于使用了两个指针，一个用于原始数组的迭代，另一个总是指向新数组的最后一个位置。

**考虑空间限制**
如果我们不使用额外的数组，只是在原数组上进行操作呢？

此时，我们就可以采用快慢指针的思想：初始化一个快指针 `fast` 和一个慢指针 `slow`，`fast` 每次移动一步，而 `slow` 只当 `fast` 指向的值不等于 `val` 时才移动一步。

<img src="https://pic.leetcode-cn.com/353657e00bf49ad5c6aeb8e97414d1d610083acdb580e7c2b0fe036a523129f5-4.gif" alt="4.gif" style="zoom:40%;" />

**小节**：

这是你需要使用双指针技巧的另一种非常常见的情况：

> 同时有一个慢指针和一个快指针。

解决这类问题的关键是:

> 确定两个指针的移动策略。

与前一个场景类似，你有时可能需要在使用双指针技巧之前对数组进行排序，也可能需要运用贪心法则来决定你的运动策略。首先它是通向指针，其次它必然是快慢指针，对于每个同向双指针的题目需要考虑这么几个点:

- 快指针什么时候移动？
- 慢指针什么时候移动？
- 快慢指针移动步数时候有联系？

## 5.4 经典例题

### 5.4.1 移除元素[27]

给你一个数组 `nums` 和一个值 `val`，你需要 **[原地](https://baike.baidu.com/item/原地算法)** 移除所有数值等于 `val` 的元素，并返回移除后数组的新长度。

不要使用额外的数组空间，你必须仅使用 `O(1)` 额外空间并 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组**。

元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。

 

**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参作任何拷贝
int len = removeElement(nums, val);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

 

**示例 1：**

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2]
解释：函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。例如，函数返回的新长度为 2 ，而 nums = [2,2,3,3] 或 nums = [2,2,0,0]，也会被视作正确答案。
```

**示例 2：**

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3]
解释：函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。
```

 

**提示：**

- `0 <= nums.length <= 100`
- `0 <= nums[i] <= 50`
- `0 <= val <= 100`

**解法**：

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int fast = 0;
        int slow = 0;
        while (fast < nums.length) {
            if (nums[fast] != val) {
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
}
```



### 5.4.2 最大连续1的个数[485]

给定一个二进制数组， 计算其中最大连续 1 的个数。

 

**示例：**

```
输入：[1,1,0,1,1,1]
输出：3
解释：开头的两位和最后的三位都是连续 1 ，所以最大连续 1 的个数是 3.
```

 

**提示：**

- 输入的数组只包含 `0` 和 `1` 。
- 输入数组的长度是正整数，且不超过 10,000。



**解法**：

```java
class Solution {
    public int findMaxConsecutiveOnes(int[] nums) {
        int maxLen = 0;
        int fast = 0;
        int slow = 0;
        while (fast < nums.length) {
            if (nums[fast] != 1) {
                if (fast - slow > maxLen) {
                    maxLen = fast - slow;
                }
                slow = ++fast;
            } else {
                fast++;
            }
        }
        if (fast != slow) {
            if (fast - slow > maxLen) {
                maxLen = fast - slow;
            }
        }
        return maxLen;
    }
}
```

### 5.4.3 长度最小的子数组[209]

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其和 `≥ target` 的长度最小的 **连续子数组** `[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

 

**示例 1：**

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

**示例 2：**

```
输入：target = 4, nums = [1,4,4]
输出：1
```

**示例 3：**

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

 

**提示：**

- `1 <= target <= 109`
- `1 <= nums.length <= 105`
- `1 <= nums[i] <= 105`

 

**解法**：

```java
// 解法一：暴力解法
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int minLen = nums.length;
        int fast = 0;
        int slow = 0;
        boolean flag = false;

        while (fast < nums.length) {
            if (sumArray(nums, slow, fast) < target) {
                fast++;
            } else {
                if (fast - slow + 1 <= minLen) {
                    minLen = fast - slow + 1;
                    flag = true;
                }
                slow++;
            }
        }
        if (flag) return minLen;
        return 0;
    }

    public int sumArray(int nums[], int start, int end) {
        int sum = 0;
        for (int i = start; i <= end; i++) {
            sum += nums[i];
        }
        return sum;
    }
}

// 解法二：滑动窗口（快慢指针）
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int n = nums.length;
        int minLen = Integer.MAX_VALUE;
        int fast = 0;
        int slow = 0;
        int sum = 0;
        while (slow < n) {
            if (sum < target) {
                if (fast < n) {
                    sum += nums[fast++];
                } else {
                    break;
                }
            } else {
                minLen = Math.min(fast - slow, minLen);
                sum -= nums[slow++];
            }
        }
        return minLen == Integer.MAX_VALUE ? 0 : minLen;
    }
}
```



# 六 小结

本章节中，我们提供了数组相关的数据结构的介绍，以及相关技巧的运用。有关更多数组相关的算法，我们将在其他 LeetBook 中进行详细介绍，以帮助你逐一征服这些主题。

我们也为你准备了一些与数组/字符串相关的练习。请试着自己动手解决这些问题。

## 6.1 数组相关的技术

你可能想要了解更多与数组相关的数据结构或技术，你可以在其他 「探索」卡片中进行深入学习，我们将在下方提供相应的卡片链接。

1. 这里有一些其他类似于数组的数据结构，但具有一些不同的属性：

- 字符串（已包含在本 LeetBook 中）
- 哈希表
- 链表
- 队列
- 栈

2. 正如我们所提到的，我们可以调用内置函数来对数组进行排序。但是，理解一些广泛使用的排序算法的原理及其复杂度是很有用的。

3. **二分查找**也是一种重要的技术，用于在排序数组中搜索特定的元素。

4. 我们在这一章中引入了双指针技巧。想要灵活运用该技巧是不容易的。这一技巧也可以用来解决：

   - 链表中的慢指针和快指针问题

   - 滑动窗口问题

5. 双指针技巧有时与贪心算法有关，它可以帮助我们设计指针的移动策略。 我们将会提供更多的卡片来介绍上面提到的这些技术，并更新链接。



## 6.2 经典例题

### 6.2.1 杨辉三角[118]

给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

 

**示例 1:**

```
输入: numRows = 5
输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]
```

**示例 2:**

```
输入: numRows = 1
输出: [[1]]
```

 

**提示:**

- `1 <= numRows <= 30`

**解法**：

```java
class Solution {
    public List<List<Integer>> generate(int numRows) {
        List<List<Integer>> list1 = new ArrayList<List<Integer>>();
        for (int i = 1; i <= numRows; i++) {
            List<Integer> list2 = new ArrayList<Integer>();
            if (i == 1) {
                list2.add(1);
            } else if (i == 2) {
                list2.add(1);
                list2.add(1);
            } else {
                list2.add(1);
                for (int j = 0; j < i - 2; j++) {
                    int val1 = list1.get(i - 2).get(j);
                    int val2 = list1.get(i - 2).get(j + 1);
                    list2.add(val1 + val2);
                }
                list2.add(1);
            }
            list1.add(list2);
        }
        return list1;
    }
}
```

### 6.2.2 杨辉三角II[119]

给定一个非负索引 `rowIndex`，返回「杨辉三角」的第 `rowIndex` 行。

在「杨辉三角」中，每个数是它左上方和右上方的数的和。

![img](https://pic.leetcode-cn.com/1626927345-DZmfxB-PascalTriangleAnimated2.gif)

 

**示例 1:**

```
输入: rowIndex = 3
输出: [1,3,3,1]
```

**示例 2:**

```
输入: rowIndex = 0
输出: [1]
```

**示例 3:**

```
输入: rowIndex = 1
输出: [1,1]
```

 

**提示:**

- `0 <= rowIndex <= 33`



**解法**：

```java
class Solution {
    public List<Integer> getRow(int rowIndex) {
        List<Integer> row = new ArrayList<Integer>();
        row.add(1);
        for (int i = 1; i <= rowIndex; ++i) {
            row.add(0);
            for (int j = i; j > 0; --j) {
                row.set(j, row.get(j) + row.get(j - 1));
            }
        }
        return row;
    }
}
```

### 6.2.3 反转字符串中的单词 III[557]

给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。

 

**示例：**

```
输入："Let's take LeetCode contest"
输出："s'teL ekat edoCteeL tsetnoc"
```

 

**提示：**

- 在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。

**解法**：

```java
class Solution {
    public String reverseWords(String s) {
        int fast = 0;
        int slow = 0;
        char[] chars = s.toCharArray();
        while (fast < s.length()) {
            if (chars[fast] != ' ') {
                fast++;
            } else {
                if (chars[slow] == ' ') {
                    slow++;
                } else {
                    int left = slow;
                    int right = fast - 1;
                    while (left < right) {
                        char temp = chars[right];
                        chars[right--] = chars[left];
                        chars[left++] = temp;
                    }
                    slow = ++fast;
                }
            }
        }
        int left = slow;
        int right = fast - 1;
        while (left < right) {
            char temp = chars[right];
            chars[right--] = chars[left];
            chars[left++] = temp;
        }
        return new String(chars);
    }
}
```



### 6.2.4 寻找旋转排序数组中的最小值[153]

已知一个长度为 `n` 的数组，预先按照升序排列，经由 `1` 到 `n` 次 **旋转** 后，得到输入数组。例如，原数组 `nums = [0,1,2,4,5,6,7]` 在变化后可能得到：

- 若旋转 `4` 次，则可以得到 `[4,5,6,7,0,1,2]`
- 若旋转 `7` 次，则可以得到 `[0,1,2,4,5,6,7]`

注意，数组 `[a[0], a[1], a[2], ..., a[n-1]]` **旋转一次** 的结果为数组 `[a[n-1], a[0], a[1], a[2], ..., a[n-2]]` 。

给你一个元素值 **互不相同** 的数组 `nums` ，它原来是一个升序排列的数组，并按上述情形进行了多次旋转。请你找出并返回数组中的 **最小元素** 。

 

**示例 1：**

```
输入：nums = [3,4,5,1,2]
输出：1
解释：原数组为 [1,2,3,4,5] ，旋转 3 次得到输入数组。
```

**示例 2：**

```
输入：nums = [4,5,6,7,0,1,2]
输出：0
解释：原数组为 [0,1,2,4,5,6,7] ，旋转 4 次得到输入数组。
```

**示例 3：**

```
输入：nums = [11,13,15,17]
输出：11
解释：原数组为 [11,13,15,17] ，旋转 4 次得到输入数组。
```

 

**提示：**

- `n == nums.length`
- `1 <= n <= 5000`
- `-5000 <= nums[i] <= 5000`
- `nums` 中的所有整数 **互不相同**
- `nums` 原来是一个升序排序的数组，并进行了 `1` 至 `n` 次旋转



**解法**：

```java
class Solution {
    public int findMin(int[] nums) {
        int left = 0;
        int right = nums.length - 1;
        while (left < right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] < nums[right]) right = mid;
            else left = mid + 1;
        }
        return nums[left]; 
    }
}
```

### 6.2.5 删除排序数组中的重复项[26]

给你一个有序数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。

不要使用额外的数组空间，你必须在 **[原地 ](https://baike.baidu.com/item/原地算法)修改输入数组** 并在使用 O(1) 额外空间的条件下完成。

 

**说明:**

为什么返回数值是整数，但输出的答案是数组呢?

请注意，输入数组是以**「引用」**方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。

你可以想象内部操作如下:

```
// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝
int len = removeDuplicates(nums);

// 在函数里修改输入数组对于调用者是可见的。
// 根据你的函数返回的长度, 它会打印出数组中 该长度范围内 的所有元素。
for (int i = 0; i < len; i++) {
    print(nums[i]);
}
```

 

**示例 1：**

```
输入：nums = [1,1,2]
输出：2, nums = [1,2]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

**示例 2：**

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

 

**提示：**

- `0 <= nums.length <= 3 * 104`
- `-104 <= nums[i] <= 104`
- `nums` 已按升序排列

 

**解法**：

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int fast = 0;
        int slow = 0;
        while (fast < nums.length) {
            if (nums[fast] == nums[slow]) {
                fast++;
            } else {
                slow++;
                int temp = nums[slow];
                nums[slow] = nums[fast];
                nums[fast] = temp;
                fast++;
            }
        }
        return slow + 1;
    }
} 
```



### 6.2.6 移动零[283]

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**示例:**

```
输入: [0,1,0,3,12]
输出: [1,3,12,0,0]
```

**说明**:

1. 必须在原数组上操作，不能拷贝额外的数组。
2. 尽量减少操作次数。

**解法**：

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int fast = 0;
        int slow = 0;
        while (fast < nums.length) {
            // 再对 fast 进行判断
            if (nums[fast] == 0) {
                fast++;
            } else {
                if (nums[slow] == 0) {
                    int temp = nums[slow];
                    nums[slow] = nums[fast];
                    nums[fast] = temp;
                } else {
                    while (slow < fast && nums[slow] != 0) {
                        slow++;
                    }
                    if (slow != fast) {
                        int temp = nums[slow];
                        nums[slow] = nums[fast];
                        nums[fast] = temp;
                    }
                }
                fast++;
                slow++;
            }
        }
    }
}
```

