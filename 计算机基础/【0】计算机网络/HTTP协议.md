# HTTP协议

- 无连接：
- 媒体独立：MIME TPYE（规范）
- 无状态：因为无状态协议不要求服务器在多个请求期间保留关于每个通信伙伴的会话信息或状态。HTTP是无状态协议，这意味着一旦事务结束，浏览器和服务器之间的连接就会丢失。

# HTTP报文格式

## Request请求报文

![v2-35f1c5d87385f16381d76cc08354f046_720w](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/v2-35f1c5d87385f16381d76cc08354f046_720w.jpg)

![20170330192653242](C:\Users\Susanoo\Desktop\20170330192653242.png)

**注:** URI=Uniform Resource Identifiers 不等于 URL，可以看作URL 后面部分

## Response响应报文

![v2-eedcfa2b41065ec757108aa5472c874b_720w](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/v2-eedcfa2b41065ec757108aa5472c874b_720w.jpg)

![20170330192754102](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/20170330192754102.png)

# HTTP 1.0、1.2、1.2、2.0、3.0

http://assets.processon.com/chart_image/6215e60de401fd06e2e07a2d.png

![6215e60de401fd06e2e07a2d](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/6215e60de401fd06e2e07a2d.png)

# 状态码

http://assets.processon.com/chart_image/6215f9bce0b34d075bac58ba.png

![6215f9bce0b34d075bac58ba](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/6215f9bce0b34d075bac58ba.png)

# HTTP请求与响应过程（从输入URL到页面加载发生了什么）

![url输入到展示出来的过程](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/url输入到展示出来的过程.jpg)

总体来说分为以下几个过程:

1. DNS 解析
2. TCP 连接
3. 发送 HTTP 请求
4. 服务器处理请求并返回 HTTP 报文
5. 浏览器解析渲染页面
6. 连接结束

# 简述 HTTP 的 keepalive 的原理和使用场景

## 什么是Keep-Alive模式？

我们知道HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成之后立即断开连接（HTTP协议为无连接的协议）；当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。

![450px-HTTP_persistent_connection.svg](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/450px-HTTP_persistent_connection.svg.png)

http 1.0中默认是关闭的，需要在http头加入"Connection: Keep-Alive"，才能启用Keep-Alive；http 1.1中默认启用Keep-Alive，如果加入"Connection: close "，才关闭。目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep-Alive连接就看服务器设置情况。

## 启用Keep-Alive的优点

从上面的分析来看，启用Keep-Alive模式肯定更高效，性能更高。因为避免了建立/释放连接的开销。下面是[RFC 2616](http://tools.ietf.org/html/rfc2616)上的总结：

1. 通过打开和关闭更少的 TCP 连接，可以在路由器和主机（客户端、服务器、代理、网关、隧道或缓存）中节省 CPU 时间，并且可以在主机中节省用于 TCP 协议控制块的内存。
2. HTTP 请求和响应可以在连接上进行管道传输。 流水线允许客户端在不等待每个响应的情况下发出多个请求，从而可以更有效地使用单个 TCP 连接，并且花费的时间要短得多。
3. 通过减少由 TCP 打开引起的数据包数量，并允许 TCP 有足够的时间来确定网络的拥塞状态，可以减少网络拥塞。
4. 由于在 TCP 的连接打开握手中没有花费时间，因此减少了后续请求的延迟。
5. HTTP 可以更优雅地发展，因为可以报告错误而无需关闭 TCP 连接。 使用 HTTP 未来版本的客户端可能会乐观地尝试新功能，但如果与旧服务器通信，请在报告错误后使用旧语义重试。

[RFC 2616](http://tools.ietf.org/html/rfc2616)（P47）还指出：单用户客户端与任何服务器或代理之间的连接数不应该超过2个。一个代理与其它服务器或代码之间应该使用超过2 * N的活跃并发连接。这是为了提高HTTP响应时间，避免拥塞（冗余的连接并不能代码执行性能的提升）。

## 如何判断消息内容/长度的大小？

**非keep-alive**：**HTTP协议中客户端发送一个小请求，服务器响应以所期望的信息（例如一个html文件或一副gif图像）。服务器通常在发送回所请求的数据之后就关闭连接。这样客户端读数据时会返回EOF（-1），就知道数据已经接收完全了。**

Keep-Alive模式，客户端如何判断请求所得到的响应数据已经接收完成（或者说如何知道服务器已经发生完了数据）？我们已经知道了，Keep-Alive模式发送玩数据HTTP服务器不会自动断开连接，所有不能再使用返回EOF（-1）来判断（当然你一定要这样使用也没有办法，可以想象那效率是何等的低）！下面我介绍两种来判断方法。

## 使用消息首部字段Conent-Length

故名思意，Conent-Length表示实体内容长度，客户端（服务器）可以根据这个值来判断数据是否接收完成。

由于Content-Length字段必须真实反映响应体长度，但实际应用中，有些时候响应体长度并没那么好获得，例如响应体来自于网络文件，或者由动态语言生成。这时候要想准确获取长度，只能先开一个足够大的内存空间，等内容全部生成好再计算。但这样做一方面需要更大的内存开销，另一方面也会让客户端等更久。但是如果消息中没有Conent-Length，那该如何来判断呢？又在什么情况下会没有Conent-Length呢？请继续往下看……

## 使用消息首部字段Transfer-Encoding

当客户端向服务器请求一个静态页面或者一张图片时，服务器可以很清楚的知道内容大小，然后通过Content-length消息首部字段告诉客户端需要接收多少数据。但是如果是动态页面等时，服务器是不可能预先知道内容大小，这时就可以使用Transfer-Encoding：chunk模式来传输数据了。即如果要一边产生数据，一边发给客户端，服务器就需要使用"Transfer-Encoding: chunked"这样的方式来代替Content-Length。

chunk编码将数据分成一块一块的发生。Chunked编码将使用若干个Chunk串连而成，由一个标明**长度为0**的chunk标示结束。每个Chunk分为头部和正文两部分，头部内容指定正文的字符总数（**十六进制的数字**）和数量单位（一般不写），正文部分就是指定长度的实际内容，两部分之间用**回车换行(CRLF)**隔开。在最后一个长度为0的Chunk中的内容是称为footer的内容，是一些附加的Header信息（通常可以直接忽略）。

> Chunk编码的格式如下：
>
> Chunked-Body = ***chunk**
>                   "0" CRLF
>                   footer
>                   CRLF 
> chunk = chunk-size [ chunk-ext ] CRLF
>          chunk-data CRLF
>
> hex-no-zero = <HEX excluding "0">
>
> chunk-size = hex-no-zero *HEX
> chunk-ext = *( ";" chunk-ext-name [ "=" chunk-ext-value ] )
> chunk-ext-name = token
> chunk-ext-val = token | quoted-string
> chunk-data = chunk-size(OCTET)
>
> footer = *entity-header
>
> 即Chunk编码由四部分组成：1、**0至多个chunk块**，2、**"0" CRLF**，3、**footer**，4、**CRLF****.**而每个chunk块由：chunk-size、chunk-ext（可选）、CRLF、chunk-data、CRLF组成。

以分块传输一段文本内容：“人的一生总是在追求自由的一生 So easy”来说明分块传输的过程，如下图所示

![aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI5MTcxMTQwODc3](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/aHR0cDovL2ltZy5ibG9nLmNzZG4ubmV0LzIwMTcxMDI5MTcxMTQwODc3.png)

图中每个分块的第一行是分块内容的大小，十六进制表示，后面跟CRLF(\r\n)，第一行本身以及分块内容末尾的CRLF不计入大小。第二行是分块内容，后面也跟CRLF。最后一个分块虽然大小为零，但是必不可少，表示分块的结束，后面也跟CRLF，同时内容为空。最后，响应体以CRLF结束。将它们结合起来的响应内容就是：
![image-20220223204019496](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220223204019496.png)

不过以上格式的响应体内容用浏览器自带的调试工具是看不出来的，浏览器自带调试工具对分块传输和非分块传输响应体的显示是一样的，要想看到区别，需要用Wireshark、Fiddler等抓包工具查看。

## 消息长度的总结

其实，上面2中方法都可以归纳为是如何判断http消息的大小、消息的数量。[RFC 2616](http://tools.ietf.org/html/rfc2616)对消息的长度总结如下：一个消息的transfer-length（传输长度）是指消息中的message-body（消息体）的长度。当应用了transfer-coding（传输编码），每个消息中的message-body（消息体）的长度（transfer-length）由以下几种情况决定（优先级由高到低）：

- 任何不含有消息体的消息（如1XXX、204、304等响应消息和任何头(HEAD，首部)请求的响应消息），总是由一个空行（CLRF）结束。
- 如果出现了Transfer-Encoding头字段 并且值为非“identity”，那么transfer-length由“chunked” 传输编码定义，除非消息由于关闭连接而终止。
- 如果出现了Content-Length头字段，它的值表示entity-length（实体长度）和transfer-length（传输长度）。如果这两个长度的大小不一样（i.e.设置了Transfer-Encoding头字段），那么将不能发送Content-Length头字段。并且如果同时收到了Transfer-Encoding字段和Content-Length头字段，那么必须忽略Content-Length字段。
- 如果消息使用媒体类型“multipart/byteranges”，并且transfer-length 没有另外指定，那么这种自定界（self-delimiting）媒体类型定义transfer-length 。除非发送者知道接收者能够解析该类型，否则不能使用该类型。
- 由服务器关闭连接确定消息长度。（注意：关闭连接不能用于确定请求消息的结束，因为服务器不能再发响应消息给客户端了。）

为了兼容HTTP/1.0应用程序，HTTP/1.1的请求消息体中必须包含一个合法的Content-Length头字段，除非知道服务器兼容HTTP/1.1。一个请求包含消息体，并且Content-Length字段没有给定，如果不能判断消息的长度，服务器应该用用400 (bad request) 来响应；或者服务器坚持希望收到一个合法的Content-Length字段，用 411 (length required)来响应。

所有HTTP/1.1的接收者应用程序必须接受“chunked” transfer-coding (传输编码)，因此当不能事先知道消息的长度，允许使用这种机制来传输消息。消息不应该够同时包含 Content-Length头字段和non-identity transfer-coding。如果一个消息同时包含non-identity transfer-coding和Content-Length ，必须忽略Content-Length 。

## keepalive 是否开启服务端控制还是客户端控制？

keepalive可以由双方共同控制，需要双方都开启才能生效，HTTP1.1客户端默认开启，客户端想关闭可以通过设置Connection: Close，服务端同样想关闭可以设置Connection: Close。双方哪方先收到Connection: Close 则由收到方关闭（前提是双方的实现都支持，比如telnet就不支持）

## keepalive时间一到，是由客户端主动关闭还是服务端主动关闭？

哪方的时间短，由哪一方来关闭，除非双方的实现有更明确的协议



# HTTP keep-alive和TCP keepalive的区别

## HTTP keep-alive

**keep-alive**机制：若开启后，在一次http请求中，服务器进行响应后，不再直接断开TCP连接，而是将TCP连接维持一段时间。在这段时间内，如果同一客户端再次向服务端发起http请求，便可以复用此TCP连接，向服务端发起请求，并重置timeout时间计数器，在接下来一段时间内还可以继续复用。这样无疑省略了反复创建和销毁TCP连接的损耗。

## TCP keepalive

在客户端和服务端间的网络一切正常、且双方都没主动发起关闭连接的请求时，此TCP连接理论上可以永久保持。但是，网络情况是及其复杂的，**在双方长时间未通讯时，如何得知对方还活着？如何得知这个TCP连接是健康且具有通讯能力的？**

HTTP协议运行在TCP协议之上，它无状态会导致客户端的每次请求都需要重新建立TCP连接，接受到服务端响应后，断开TCP连接。对于每次建立、断开TCP连接，还是有相当的性能损耗的。**那么，如何才能尽可能的减少性能损耗呢？**

正如上面提出的问题：**在双方长时间未通讯时，如何得知对方还活着？如何得知这个TCP连接是健康且具有通讯能力的？**

TCP的保活机制就是用来解决此类问题，这个机制我们也可以称作：keepalive。保活机制默认是关闭的，TCP连接的任何一方都可打开此功能。有三个主要配置参数用来控制保活功能。

如果在一段时间（**保活时间：tcp_keepalive_time**）内此连接都不活跃，开启保活功能的一端会向对端发送一个保活探测报文。

- 若对端正常存活，且连接有效，对端必然能收到探测报文并进行响应。此时，发送端收到响应报文则证明TCP连接正常，重置保活时间计数器即可。
- 若由于网络原因或其他原因导致，发送端无法正常收到保活探测报文的响应。那么在一定**探测时间间隔（tcp_keepalive_intvl）**后，将继续发送保活探测报文。直到收到对端的响应，或者达到配置的**探测循环次数上限（tcp_keepalive_probes）**都没有收到对端响应，这时对端会被认为不可达，TCP连接随存在但已失效，需要将连接做中断处理。

在探测过程中，对端主机会处于以下四种状态之一：

![v2-837ba2a1eb7beb10c036ca468f7db69f_720w](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/v2-837ba2a1eb7beb10c036ca468f7db69f_720w.jpg)

TCP keepalive指的是TCP保活计时器（keepalive timer）。设想有这样的情况：客户已主动与服务器建立了TCP连接。但后来客户端的主机突然出故障。显然，服务器以后就不能再收到客户发来的数据。因此，应当有措施使服务器不要再白白等待下去。这就是使用保活计时器。服务器每收到一次客户的数据，就重新设置保活计时器，时间的设置通常是两小时。若两小时没有收到客户的数据，服务器就发送一个探测报文段，以后则每隔75秒发送一次。若一连发送10个**探测报文段**后仍无客户的响应，服务器就认为客户端出了故障，接着就关闭这个连接。



# HTTP的缓存机制

Http 缓存机制作为 web 性能优化的重要手段，对于从事 Web 开发的同学们来说，应该是知识体系库中的一个基础环节，同时对于有志成为前端架构师的同学来说是必备的知识技能。
但是对于很多前端同学来说，仅仅只是知道浏览器会对请求的静态文件进行缓存，但是为什么被缓存，缓存是怎样生效的，却并不是很清楚。

## HTTP报文

HTTP报文就是浏览器和服务器间通信时发送及响应的数据块。
浏览器向服务器请求数据，发送请求(request)报文；服务器向浏览器返回数据，返回响应(response)报文。
报文信息主要分为两部分
1.包含属性的首部(header)------------------附加信息（cookie，缓存信息等）==与缓存相关的规则信息，均包含在header中==
2.包含数据的主体部分(body)---------------HTTP请求真正想要传输的部分

## 缓存规则解析

为方便大家理解，我们认为浏览器存在一个缓存数据库，用于存储缓存信息。
在客户端第一次请求数据时，此时缓存数据库中没有对应的缓存数据，需要请求服务器，服务器返回后，将数据存储至缓存数据库中。

![632130-20170210141639213-1923993391](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/632130-20170210141639213-1923993391.png)

HTTP缓存有多种规则，根据是否需要重新向服务器发起请求来分类，我将其分为两大类(**强制缓存**，**对比缓存**)
在详细介绍这两种规则之前，先通过时序图的方式，让大家对这两种规则有个简单了解。

已存在缓存数据时，仅基于==强制缓存==，请求数据的流程如下

![image-20220223205752108](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220223205752108.png)

已存在缓存数据时，仅基于==对比缓存==，请求数据的流程如下

![image-20220223205837251](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220223205837251.png)

对缓存机制不太了解的同学可能会问，基于==对比缓存==的流程下，不管是否使用缓存，都需要向服务器发送请求，那么还用缓存干什么？这个问题，我们暂且放下，后文在详细介绍每种缓存规则的时候，会带给大家答案。

我们可以看到两类缓存规则的不同，==强制缓存==如果生效，不需要再和服务器发生交互，而==对比缓存==不管是否生效，都需要与服务端发生交互。两类缓存规则可以同时存在，==强制缓存==优先级高于==对比缓存==，也就是说，当执行==强制缓存==的规则时，如果缓存生效，直接使用缓存，不再执行==对比缓存==规则。

## 强制缓存

从上文我们得知，强制缓存，在缓存数据未失效的情况下，可以直接使用缓存数据，那么浏览器是**如何判断缓存数据是否失效**呢？我们知道，在没有缓存数据的时候，浏览器向服务器请求数据时，服务器会将数据和缓存规则一并返回，**缓存规则信息包含在响应header中**。

对于强制缓存来说，响应header中会有两个字段来标明失效规则（==Expires/Cache-Control==）

使用chrome的开发者工具，可以很明显的看到对于强制缓存生效时，网络请求的情况

![632130-20170210141755072-1978466289](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/632130-20170210141755072-1978466289.png)

### Expires

Expires的值为服务端返回的到期时间，即下一次请求时，请求时间小于服务端返回的到期时间，直接使用缓存数据。
不过Expires 是HTTP 1.0的东西，现在默认浏览器均默认使用HTTP 1.1，所以它的作用基本忽略。
另一个问题是，到期时间是由服务端生成的，但是客户端时间可能跟服务端时间有误差，这就会导致缓存命中的误差。
所以HTTP 1.1 的版本，使用==Cache-Control==替代。

### Cache-Control

Cache-Control 是最重要的规则。常见的取值有private、public、no-cache、max-age，no-store，默认为private。

==private:        客户端可以缓存
public:         客户端和代理服务器都可缓存（前端的同学，可以认为public和private是一样的）
max-age=xxx:  缓存的内容将在 xxx 秒后失效
no-cache:      需要使用对比缓存来验证缓存数据（后面介绍）
no-store:       所有内容都不会缓存，强制缓存，对比缓存都不会触发（对于前端开发来说，缓存越多越好，so...基本上和它说886）==

举个板栗：

![632130-20170210141836104-1513192908](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/632130-20170210141836104-1513192908.png)

图中Cache-Control仅指定了max-age，所以默认为private，缓存时间为31536000秒（365天）
也就是说，在365天内再次请求这条数据，都会直接获取缓存数据库中的数据，直接使用。

## 对比缓存

==对比缓存==，顾名思义，需要进行比较判断是否可以使用缓存。
浏览器第一次请求数据时，服务器会将缓存标识与数据一起返回给客户端，客户端将二者备份至缓存数据库中。
再次请求数据时，客户端将备份的缓存标识发送给服务器，服务器根据缓存标识进行判断，判断成功后，返回304状态码，通知客户端比较成功，可以使用缓存数据。

**第一次访问：**

![632130-20170210141911682-1756976419](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/632130-20170210141911682-1756976419.png)

**再次访问：**

![632130-20170210141921697-379821074](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/632130-20170210141921697-379821074.png)

通过两图的对比，我们可以很清楚的发现，在==对比缓存==生效时，状态码为304，并且报文大小和请求时间大大减少。
原因是，服务端在进行标识比较后，只返回header部分，通过状态码通知客户端使用缓存，不再需要将报文主体部分返回给客户端。

对于==对比缓存==来说，缓存标识的传递是我们着重需要理解的，它在请求header和响应header间进行传递，
一共分为两种标识传递，接下来，我们分开介绍。

### Last-Modified / If-Modified-Since

Last-**Modified：**

服务器在响应请求时，告诉浏览器资源的最后修改时间。

![632130-20170210142249541-789089587](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/632130-20170210142249541-789089587.png)

If-Modified-**Since:**

再次请求服务器时，通过此字段通知服务器上次请求时，服务器返回的资源最后修改时间。
服务器收到请求后发现有头If-Modified-Since 则与被请求资源的最后修改时间进行比对。
若资源的最后修改时间大于If-Modified-Since，说明资源又被改动过，则响应整片资源内容，返回状态码200；
若资源的最后修改时间小于或等于If-Modified-Since，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。

![632130-20170210142307166-135607673](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/632130-20170210142307166-135607673.png)

### Etag / If-None-Match（优先级高于Last-Modified / If-Modified-Since）

**Etag：**

服务器响应请求时，告诉浏览器当前资源在服务器的唯一标识（生成规则由服务器决定）。

![632130-20170210142054182-1766818273](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/632130-20170210142054182-1766818273.png)

**If-None-Match：**

再次请求服务器时，通过此字段通知服务器客户段缓存数据的唯一标识。
服务器收到请求后发现有头If-None-Match 则与被请求资源的唯一标识进行比对，
不同，说明资源又被改动过，则响应整片资源内容，返回状态码200；
相同，说明资源无新修改，则响应HTTP 304，告知浏览器继续使用所保存的cache。

![632130-20170210142115479-1921175758](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/632130-20170210142115479-1921175758.png)

## 总结

**对于强制缓存，服务器通知浏览器一个缓存时间，在缓存时间内，下次请求，直接用缓存，不在时间内，执行比较缓存策略。
对于比较缓存，将缓存信息中的Etag和Last-Modified通过请求发送给服务器，由服务器校验，返回304状态码时，浏览器直接使用缓存。**

### 浏览器第一次请求

![632130-20170210142134291-1976923079](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/632130-20170210142134291-1976923079.png)

### 浏览器再次请求时

![632130-20170210141453338-1263276228](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/632130-20170210141453338-1263276228.png)

# HTTP 中 GET 和 POST 区别

- GET在浏览器回退时是无害的，而POST会再次提交请求。
- GET产生的URL地址可以被Bookmark，而POST不可以。
- GET请求会被浏览器主动cache，而POST不会，除非手动设置。
- GET请求只能进行url编码，而POST支持多种编码方式。
- GET请求参数会被完整保留在浏览器历史记录里，而POST中的参数不会被保留。
- GET请求在URL中传送的参数是有长度限制的，而POST么有。
- 对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
- GET比POST更不安全，因为参数直接暴露在URL上，所以不能用来传递敏感信息。
- GET参数通过URL传递，POST放在Request body中。



**误区：**

对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；

而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

首先，在那篇英文文章中并没有提及这一点。其次，我在测试时也没有看到服务器响应 100 continue。RFC 里讲的很明白：100 continue 只有在请求里带了

```text
Expect: 100-continue
```

header 的时候才有意义。

实际上，不论哪一种浏览器，在发送 POST 的时候都没有带 Expect 头，server 也自然不会发 100 continue。通过抓包发现，尽管会分两次，body 就是紧随在 header 后面发送的，根本不存在『等待服务器响应』这一说。

1）如果客户端的请求头里面有这样的映射：Expect：100-continue，那么客户端先发送第一个包：请求头，并且阻塞读取服务端的回复。（2）然后服务端如果满足客户端的期望的话，会发送100 continue，否则发送417.（3）客户端读取到服务器的状态行的响应码 如果是100 continue，那么客户端就得继续发送RequestBody，否则就结束请求。回到（1）这里，如果没有Expect的请求头，那么客户端不会先发送请求头的，会把请求头和RequestBody一起发送给服务器。

# 简述 HTTP 短链接与长链接的区别

**HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。**

HTTP属于应用层协议，在传输层使用TCP协议，在网络层使用IP协议。

IP协议主要解决网络路由和寻址问题，TCP协议主要解决如何在IP层之上可靠的传递数据包，使在网络上的另一端收到发端发出的所有包，并且顺序与发出顺序一致。

TCP有可靠，面向连接的特点。

**在HTTP/1.0中，默认使用的是短连接。**

也就是说，浏览器和服务器每进行一次HTTP操作，就建立一次连接，但任务结束就中断连接。

如果客户端访问的某个HTML或其他类型的Web资源，如JavaScript文件、图像文件、CSS文件等。

当浏览器每遇到这样一个Web资源，就会建立一个HTTP会话。

**但从HTTP/1.1起，默认使用长连接，用以保持连接特性。**

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的 TCP连接不会关闭。

如果客户端再次访问这个服务器上的网页，会继续使用这一条已经建立的连接。

**长连接短连接区别：**

1.服务器端空间管理上：

Keep-Alive不会永久保持连接，因为TCP连接将会越来越多，直到把服务器的TCP连接数量撑爆到上限为止，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间；

短连接对于服务器来说管理较为简单，存在的连接都是有用的连接，不需要额外的控制手段。

2.时间上：

在客户请求频繁的情况下：若使用短连接，将在TCP的建立和关闭操作上浪费时间和带宽；

若使用长连接，就可以节省很多这样的消耗；

长连接有两个问题：

a.HTTP 1.1 基于串行文件传输数据，因此这些请求必须是有序的，所以实际上我们只是节省了建立连接的时间，而获取数据的时间并没有减少

b.最大并发数问题，假设我们在 Apache 中设置了最大并发数 300，而因为浏览器本身的限制，最大请求数为 6，那么服务器能承载的最高并发数是 50

在HTTP2中解决了这两个问题，详情请看：https://www.cnblogs.com/vickylinj/p/14194264.html

# HTTP 的方法有哪些？

HTTP请求的常用方法有：GET方法、POST方法、HEAD方法、PUT方法、DELETE方法、CONNECT方法、OPTIONS方法、TRACE方法。

**1、GET方法**

GET方法用于使用给定的URI从给定服务器中检索信息，即从指定资源中请求数据。使用GET方法的请求应该只是检索数据，并且不应对数据产生其他影响。

在GET请求的URL中发送查询字符串（名称/值对），需要这样写：

```
/test/demo_form.php?name1=value1&name2=value2
```

说明：

GET请求是可以缓存的，我们可以从浏览器历史记录中查找到GET请求，还可以把它收藏到书签中；且GET请求有长度限制，仅用于请求数据（不修改）。

注：因GET请求的不安全性，在处理敏感数据时，绝不可以使用GET请求。

**2、POST方法**

POST方法用于将数据发送到服务器以创建或更新资源，它要求服务器确认请求中包含的内容作为由URI区分的Web资源的另一个下属。

==POST请求永远不会被缓存，且对数据长度没有限制；==我们无法从浏览器历史记录中查找到POST请求。

**3、HEAD方法**

HEAD方法与GET方法相同，但没有响应体，仅传输状态行和标题部分。这对于恢复相应头部编写的元数据非常有用，而无需传输整个内容。

**4、PUT方法**

PUT方法用于将数据发送到服务器以创建或更新资源，它可以用上传的内容替换目标资源中的所有当前内容。

它会将包含的元素放在所提供的URI下，如果URI指示的是当前资源，则会被改变。如果URI未指示当前资源，则服务器可以使用该URI创建资源。

**5、DELETE方法**

DELETE方法用来删除指定的资源，它会删除URI给出的目标资源的所有当前内容。

**6、CONNECT方法**

CONNECT方法用来建立到给定URI标识的服务器的隧道；它通过简单的TCP / IP隧道更改请求连接，通常实使用解码的HTTP代理来进行SSL编码的通信（HTTPS）。

**7、OPTIONS方法**

OPTIONS方法用来描述了目标资源的通信选项，会返回服务器支持预定义URL的HTTP策略。

**8、TRACE方法**

TRACE方法用于沿着目标资源的路径执行消息环回测试；它回应收到的请求，以便客户可以看到中间服务器进行了哪些（假设任何）进度或增量。

# HTTP 是无状态的吗？需要保持状态的场景应该怎么做？

