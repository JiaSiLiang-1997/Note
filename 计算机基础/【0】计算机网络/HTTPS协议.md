# HTTPS协议

HTTPS （全称：Hyper Text Transfer Protocol over SecureSocket Layer，超文本传输安全协议），是以安全为目标的 HTTP 通道，在HTTP的基础上通过传输加密和[身份认证](https://baike.baidu.com/item/身份认证/5294713)保证了传输过程的安全性 。HTTPS 在HTTP 的基础下加入[SSL](https://baike.baidu.com/item/SSL/320778)，HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL。 HTTPS 存在不同于 HTTP 的默认端口及一个加密/身份验证层（在 HTTP与 [TCP](https://baike.baidu.com/item/TCP/33012) 之间）。这个系统提供了身份验证与加密通讯方法。它被广泛用于[万维网](https://baike.baidu.com/item/万维网/215515)上安全敏感的通讯，例如交易支付等方面。

**HTTP加上加密处理和认证以及完整性保护后即是HTTPS**

# 从网络协议的角度理解 HTTPS

![七层](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/七层.png)

HTTP：HyperText Transfer Protocol 超文本传输协议
 HTTPS：Hypertext Transfer Protocol Secure 超文本传输安全协议
 TLS：位于 HTTP 和 TCP 之间的协议，其内部有 TLS握手协议、TLS记录协议
 HTTPS 经由 HTTP 进行通信，但利用 TLS 来保证安全，即 HTTPS = HTTP + TLS

# 从密码学的角度理解 HTTPS

HTTPS 使用 TLS 保证安全，这里的“安全”分两部分，一是传输内容加密、二是服务端的身份认证，除此之外，还可以保证传输内容的完整性。

![tls流程](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/tls流程.png)

此为服务端单向认证，还有客户端/服务端双向认证，流程类似，只不过客户端也有自己的证书，并发送给服务器进行验证

# 什么是SSL、TLS、HTTPS、X.509

SSL：（Secure Socket Layer） 安全套接层，于 1994 年由网景公司设计，并于 1995 年发布了 3.0 版本;
TLS：（Transport Layer Security）传输层安全性协议，是 IETF 在 SSL3.0 的基础上设计的协议;（OpenSSL）



# HTTPS的安全通信机制

![01 图解HTTP_175](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/01 图解HTTP_175.jpg)

![01 图解HTTP_176](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/01 图解HTTP_176.jpg)

![01 图解HTTP_177](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/01 图解HTTP_177.jpg)

# 简述 HTTPS 的加密与认证过程

大家可能都听说过 HTTPS 协议之所以是安全的是因为 HTTPS 协议会对传输的数据进行加密，而加密过程是使用了非对称加密实现。但其实：**HTTPS 在内容传输的加密上使用的是对称加密，非对称加密只作用在证书验证阶段**。

HTTPS的整体过程分为证书验证和数据传输阶段，具体的交互过程如下：

![1365470-20200329155330918-112332941](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/1365470-20200329155330918-112332941.png)

① 证书验证阶段：

- 1）浏览器发起 HTTPS 请求；
- 2）服务端返回 HTTPS 证书；
- 3）客户端验证证书是否合法，如果不合法则提示告警。

② 数据传输阶段：

- 1）当证书验证合法后，在本地生成随机数；
- 2）通过公钥（这里指的是服务器的公开密钥）加密随机数，并把加密后的随机数传输到服务端；
- 3）服务端通过私钥对（服务器自己的私钥）随机数进行解密；
- 4）服务端通过客户端传入的随机数构造对称加密算法，对返回结果内容进行加密后传输。

**注意：**HTTPS采用混合加密机制

# HTTPS的混合加密机制

HTTPS采用共享密钥加密和公开密钥加密两者并用的混合加密机制。若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，其处理速度要慢。
所以应充分利用两者各自的优势，将多种方法组合起来用于通信。在交换密钥环节使用公开密钥加密方式，之后的建立通信交换报文阶段则使用共享密钥加密方式。

![image-20220224143253792](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220224143253792.png)

# 证明公开密钥正确性的证书

![image-20220224143332588](https://jsl1997.oss-cn-beijing.aliyuncs.com/note/image-20220224143332588.png)

# https加密过程，为什么不是非对称加密

首先：非对称加密的加解密效率是非常低的，而 http 的应用场景中通常端与端之间存在大量的交互，非对称加密的效率是无法接受的。

另外：在 HTTPS 的场景中只有服务端保存了私钥，一对公私钥只能实现单向的加解密，所以HTTPS 中内容传输加密采取的是对称加密，而不是非对称加密

# 为什么需要CA机构颁发证书？

防止”中间人“攻击，同时可以为网站提供身份证明。

# 使用https会被抓包吗？

会被抓包，HTTPS 只防止用户在不知情的情况下通信被监听，如果用户主动授信，是可以构建“中间人”网络，代理软件可以对传输内容进行解密。

# 中间人攻击

中间人的确无法得到浏览器生成的密钥B，这个密钥本身被公钥A加密了，只有服务器才有私钥A’解开拿到它呀！然而中间人却完全不需要拿到密钥A’就能干坏事了。请看：

1. 某网站拥有用于非对称加密的公钥A、私钥A’。
2. 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
3. **中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）**。
4. 浏览器随机生成一个用于对称加密的密钥X，用**公钥B**（浏览器不知道公钥被替换了）加密后传给服务器。
5. **中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器**。
6. 服务器拿到后用私钥A’解密得到密钥X。

这样在双方都不会发现异常的情况下，中间人得到了密钥X。**根本原因是浏览器无法确认自己收到的公钥是不是网站自己的**。那么下一步就是解决下面这个问题：

## 即如何证明浏览器收到的公钥一定是该网站的公钥？

数字签名的制作过程：

1. CA拥有非对称加密的私钥和公钥。
2. CA对证书明文信息进行hash。
3. 对hash后的值用私钥加密，得到数字签名。

明文和数字签名共同组成了数字证书，这样一份数字证书就可以颁发给网站了。
那浏览器拿到服务器传来的数字证书后，如何验证它是不是真的？（有没有被篡改、掉包）

浏览器验证过程：

1. 拿到证书，得到明文T，数字签名S。
2. 用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。
3. 用证书里说明的hash算法对明文T进行hash得到T’。
4. 比较S’是否等于T’，等于则表明证书可信。

## 为什么这样可以证明证书可信呢？我们来仔细想一下。

中间人有可能篡改证书吗？假设中间人篡改了证书的原文，由于他没有CA机构的私钥，所以无法得到此时加密后签名，无法相应地篡改签名。浏览器收到该证书后会发现原文和签名解密后的值不一致，则说明证书已被篡改。

## 中间人有可能把证书掉包吗？

假设有另一个网站B也拿到了CA机构认证的证书，它想搞垮网站A，想劫持网站A的信息。于是它成为中间人拦截到了A传给浏览器的证书，然后替换成自己的证书，传给浏览器，之后浏览器就会错误地拿到B的证书里的公钥了，会导致上文提到的漏洞。
其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了。由于没有A的私钥，因此没办法伪造。

## 为什么制作数字签名时需要哈希一次

我初学HTTPS的时候就有这个问题，似乎以上过程中hash有点多余，把hash过程去掉也能保证证书没有被篡改。
最显然的是性能问题，前面我们已经说了非对称加密效率较差，证书信息一般较长，比较耗时。而hash后得到的是固定长度的信息（比如用md5算法hash后可以得到固定的128位的值），这样加密解密就会快很多。
当然还有安全上的原因，这部分内容相对深一些，感兴趣的可以看这篇解答：[crypto.stackexchange.com/a/12780](https://link.juejin.cn/?target=https%3A%2F%2Fcrypto.stackexchange.com%2Fa%2F12780)。简单的讲就是类似md5撞库，虽然我不知道私钥，但是我将想要伪造的数据给你签名，如果你签了，我就成功的伪造了数据。因此我应该尽可能少的签名，特别是不对陌生文档签名。而证书比必须签的，签hash值而不是签源文档可能暴露的信息更少吧，参考[RSA算法-选择密码攻击部分](https://baike.baidu.com/item/RSA%E7%AE%97%E6%B3%95/263310)

## 怎么证明CA机构的公钥是可信的？

你们可能会发现上文中说到CA机构的公钥，我几乎一笔带过，“浏览器保有它的公钥”，这是个什么保有法？怎么证明这个公钥是否可信？
让我们回想一下数字证书到底是干啥的？没错，为了证明某公钥是可信的，即“该公钥是否对应该网站/机构等”，那这个CA机构的公钥是不是也可以用数字证书来证明？没错，操作系统、浏览器本身会预装一些它们信任的根证书，如果其中有该CA机构的根证书，那就可以拿到它对应的可信公钥了。

> 实际上证书之间的认证也可以不止一层，可以A信任B，B信任C，以此类推，我们把它叫做`信任链`或`数字证书链`，也就是一连串的数字证书，由根证书为起点，透过层层信任，使终端实体证书的持有者可以获得转授的信任，以证明身份。

另外，不知你们是否遇到过网站访问不了、提示要安装证书的情况？这里安装的就是跟证书。说明浏览器不认给这个网站颁发证书的机构，那么没有该机构的根证书，你就得手动下载安装（风险自己承担XD）。安装该机构的根证书后，你就有了它的公钥，就可以用它验证服务器发来的证书是否可信了。

## HTTPS必须在每次请求中都要先在SSL/TLS层进行握手传输密钥吗？

这也是我当时的困惑之一，显然每次请求都经历一次密钥传输过程非常耗时，那怎么达到只传输一次呢？靠“session”。
服务器会为每个浏览器（或客户端软件）维护一个session ID，在TSL握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！

## 总结

https由于存在证书不会发生“中间人攻击”，而数字签名可以防止证书被掉包和篡改。
